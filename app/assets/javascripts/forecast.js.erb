<% environment.context_class.instance_eval {include Rails.application.routes.url_helpers } %>
var SurfForecastData = (function() {
  SurfForecastData.name = "SurfForecastData";

  function SurfForecastData(dataElement) {
    this.day = parseInt(dataElement.getAttribute("day"), 10);
    this.hour = dataElement.getAttribute("hour");
    this.dayName = dataElement.getAttribute("day_name");
    this.month = dataElement.getAttribute("month");
    this.surf = parseInt(dataElement.getAttribute("surf"), 10);
    this.cond = dataElement.getAttribute("cond");
    this.swell1 = dataElement.getAttribute("swell1");
    this.swell2 = dataElement.getAttribute("swell2");
    this.wind = dataElement.getAttribute("wind");
  }

  return SurfForecastData;
})();

var SurfForecast = (function() {
  SurfForecast.name = "SurfForecast";

  // Constructor. Takes an options object which sets up the Surf Forecast.
  function SurfForecast(options) {
    // Create the kinetic stage we'll use to draw everything
    this.stage = new Kinetic.Stage({container: "surf_forecast", width: 709, height: 166});

    // Surf Data url is where we get the surf forecast data from
    this.locationDirs = options.locationDir.split("||");
    var locationKey = options.locationKey;

    this.filenames = {};
    this.filenames[this.locationDirs[0]] = locationKey;

    for (var i = 1; i < this.locationDirs.length; i++) {
      this.filenames[this.locationDirs[i]] = locationKey + "_" + this.locationDirs[i].toLowerCase();
    }

    // Beach Direction
    this.beachDirection = options.beachDir;

    // Set up initial properties for Sunrise
    this.sunSetHour = options.sset.substring(0, 1) + "pm";
    this.sunRiseHour = options.srise.substring(0, 1) + "am";
    this.backgroundLayer = new Kinetic.Layer();
    this.foregroundLayer = new Kinetic.Layer();
    this.mouseOverLayer = new Kinetic.Layer();
    var mouseOverTimeWhiteBackground = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.mouseOverLayer.add(mouseOverTimeWhiteBackground);
    this.mouseOverLayer.hide();
    this.mouseOverControlLayer = new Kinetic.Layer();
    this.graphWidth = 689;
    this.graphHeight = 119;
    this.graphLeft = 19.5;
    this.graphRight = this.graphLeft + this.graphWidth;
    this.graphTop = 24.5;
    this.graphBottom = 141.5;
    this.surfVerticalDataPoints = 80;
    this.mouseOverGroup = new Kinetic.Group({
      x: this.graphLeft,
      y: this.graphTop
    });

    this.stage.add(this.backgroundLayer);
    this.stage.add(this.foregroundLayer);
    this.stage.add(this.mouseOverLayer);
    this.stage.add(this.mouseOverControlLayer);
    this.fetchData();
  }

  // Private method used to get the point at the nearest 0.5. Canvas horizontal and vertical
  // lines don't look well defined at 1px unless they have a .5 in them.
  SurfForecast.prototype._getPointNear = function(point) {
    return Math.round(point + 0.5) - 0.5;
  }

  // Ajax call to get the surf forecast data
  SurfForecast.prototype.fetchData = function(direction) {
    direction = direction || this.beachDirection;
    _this = this;
    var basePath = "<%= data_timelines_path %>/";
    $.ajax(basePath + this.filenames[direction] + ".xml", {
      success: function(data, textStatus, xhr) {
        _this.bindData(data, textStatus, xhr, direction);
      },
      cache: false
    });
  }

  // Binds data to the surf forecast and sets up various utility data points
  SurfForecast.prototype.bindData = function(data, textStatus, xhr, direction) {
    var dataPoints = data.getElementsByTagName("data");
    this.surfDataUpdated = data.documentElement.getAttribute("update");
    var surfForecastDataArray = [];
    var firstDataPoint;
    for (var i = 0; i < dataPoints.length; i++) {
      var dataPoint = new SurfForecastData(dataPoints[i]);
      if (!firstDataPoint) {
        firstDataPoint = dataPoint;
      }
      if (dataPoint.day == firstDataPoint.day + 7 && dataPoint.hour == firstDataPoint.hour ) {
        break;
      } else {
        surfForecastDataArray.push(dataPoint);
      }
    }

    this.data = surfForecastDataArray;
    this.dataColumnWidth = this.graphWidth / this.data.length;
    this.surfDataHeight = this.graphHeight / this.surfVerticalDataPoints;

    if (this.backgroundLayer.get("#beachDirectionLabel").length > 0) {
      this.selectBackgroundButton(direction);
    } else {
      this.generateSurfBackground(direction);
    }
    this.generateSurfForeground();
  }

  SurfForecast.prototype.generateSurfForeground = function() {
    this.foregroundLayer.removeChildren();
    var _this = this;
    var fillConditionColors = {"0": "rgba(204, 204, 204, 0.3)",
      "1": "rgba(0, 200, 0, 0.3)",
      "2": "rgba(0, 0, 256, 0.3)",
      "3": "rgba(256, 0, 0, 0.3)"};
    var strokeConditionColors = {"0": "#CCCCCC",
      "1": "#00C800",
      "2": "#0000FF",
      "3": "#FF0000"};

    var lastCondition, lastPoint, fillPoints, fillColor, strokePoints, strokeColor, endLine;
    for (var i = 0; i < this.data.length;) {
      var dataPoint = this.data[i];

      // Start a new line
      if (lastPoint) {
        fillPoints = [((i - 1) * this.dataColumnWidth) + this.graphLeft, this.graphBottom];
        fillPoints = fillPoints.concat(lastPoint);
      } else {
        fillPoints = [(i * this.dataColumnWidth) + this.graphLeft, this.graphBottom];
      }
      fillColor = fillConditionColors[dataPoint.cond];
      strokePoints = lastPoint || [];
      strokeColor = strokeConditionColors[dataPoint.cond];

      // Add points of the same color to arrays
      lastCondition = dataPoint.cond
      while (dataPoint.cond == lastCondition && i < this.data.length) {
        dataPoint = this.data[i];
        x = (i * this.dataColumnWidth) + this.graphLeft;
        fillPoints.push(x);
        strokePoints.push(x);
        y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
        fillPoints.push(y);
        strokePoints.push(y);
        lastPoint = [x, y];


        i++;
      }

      // Extend the last data point out so the graph looks full
      if (i == this.data.length) {
        x = (i * this.dataColumnWidth) + this.graphLeft;
        fillPoints.push(x);
        strokePoints.push(x);
        y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
        fillPoints.push(y);
        strokePoints.push(y);

        // Add the bottom of the fill Poly
        fillPoints.push((i * this.dataColumnWidth) + this.graphLeft);
        fillPoints.push(this.graphBottom);
      } else {
        // If it's not the end of the graph we still need to add the bottom point of the 
        // fill poly
        fillPoints.push(((i - 1) * this.dataColumnWidth) + this.graphLeft);
        fillPoints.push(this.graphBottom);
      }

      // End the line
      var fillPoly = new Kinetic.Polygon({
        points: fillPoints,
          fill: fillColor
      });
      this.foregroundLayer.add(fillPoly);
      var strokeLine = new Kinetic.Line({
        points: strokePoints,
        stroke: strokeColor,
        strokeWidth: 1
      });
      this.foregroundLayer.add(strokeLine);
    }

    this.foregroundLayer.draw();
  }

  SurfForecast.prototype.surfMouseOverHandler = function() {
    var mousePosition = this.stage.getMousePosition();

    var mouseX = mousePosition.x;

    // get the data point
    var index = Math.round((mouseX - this.graphLeft) / this.dataColumnWidth);

    var dataPoint = this.data[index];

    var x = (index * this.dataColumnWidth) + this.graphLeft;
    var y = y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);


    this.mouseOverLayer.show();
    // Draw the data Point circle
    var circle = this.mouseOverLayer.get("#circle")[0];
    if (!circle) {
      circle = new Kinetic.Circle({
        id: "circle",
        x: x,
        y: y,
        radius: 2.5,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 1
      });
      this.mouseOverLayer.add(circle);
    } else {
      circle.show();
      circle.setPosition(x, y);
    }

    // Draw the Horizontal Line
    var horizontalLine = this.mouseOverLayer.get("#hline")[0];
    if ((x - this.graphLeft) < (this.graphWidth / 2)) {
      var points = [{x: this.graphLeft, y: y}, {x: x, y: y}];
    } else {
      var points = [{x: x, y: y}, {x: this.graphRight, y: y}];
    }
    if (!horizontalLine) {
      horizontalLine = new Kinetic.Line({
        id: "hline",
        points: points,
        stroke: "#000000",
        strokeWidth: 1
      });
      this.mouseOverLayer.add(horizontalLine);
    } else {
      horizontalLine.setPoints(points);
    }

    // Draw the Vertical Line
    var verticalLine = this.mouseOverLayer.get("#vline")[0];
    var points = [{x: x, y: this.graphBottom}, {x: x, y: y}];
    if (!verticalLine) {
      verticalLine = new Kinetic.Line({
        id: "vline",
        points: points,
        stroke: "#000000",
        strokeWidth: 1
      });
      this.mouseOverLayer.add(verticalLine);
    } else {
      verticalLine.setPoints(points);
    }

    // Draw the time label
    var timeLabel = this.mouseOverLayer.get("#timeLabel")[0];
    if (!timeLabel) {
      timeLabel = new Kinetic.Text({
        id: "timeLabel",
        x: x,
        y: this.graphBottom + 8,
        text: dataPoint.hour,
        textFill: "#000",
        fontFamily: 'Times',
        fontSize: 9
      });
      this.mouseOverLayer.add(timeLabel);
    } else {
      timeLabel.setText(dataPoint.hour);
      timeLabel.setPosition(x, this.graphBottom + 8);
    }

    // Draw the Info Box
    var infoBox = this.mouseOverLayer.get("#infoBox")[0];
    if ((x - this.graphLeft) < (this.graphWidth / 2)) {
      var infoX = x + 25;
    } else {
      var infoX = x - 173;
    }
    if ((y - this.graphTop) > (this.graphHeight / 2)) {
      var infoY = y - 47;
    } else {
      var infoY = y;
    }
    if (!infoBox) {
      infoBox = new Kinetic.Group({
        id: "infoBox",
        x: infoX,
        y: infoY,
      });
      var rect = new Kinetic.Rect({
        width: 148,
        height: 47,
        fill: "#000"
      });
      rect.setCornerRadius(6);
      infoBox.add(rect);

      var swellsLabel = new Kinetic.Text({
        x: 5,
        y: 5,
        text: "Swells:",
        textFill: "#FFFFCC",
        fontSize: 7,
        fontFamily: "Verdana"
      });
      infoBox.add(swellsLabel);

      var swells1Data = new Kinetic.Text({
        id: "swell1Data",
        x: 40,
        y: 5,
        textFill: "#FFFFFF",
        fontSize: 7,
        fontFamily: "Verdana",
        text: dataPoint.swell1
      });
      infoBox.add(swells1Data);
      var swells2Data = new Kinetic.Text({
        id: "swell2Data",
        x: 40,
        y: 20,
        textFill: "#FFFFFF",
        fontSize: 7,
        fontFamily: "Verdana",
        text: dataPoint.swell2
      });
      infoBox.add(swells2Data);

      var windLabel = new Kinetic.Text({
        x: 5,
        y: 34,
        text: "Wind:",
        textFill: "#FFFFCC",
        fontSize: 7,
        fontFamily: "Verdana"
      });
      infoBox.add(windLabel);

      var windData = new Kinetic.Text({
        id: "windData",
        x: 40,
        y: 34,
        textFill: "#FFFFFF",
        fontSize: 7,
        fontFamily: "Verdana",
        text: dataPoint.wind
      });
      infoBox.add(windData);
      this.mouseOverLayer.add(infoBox);
    } else {
      infoBox.setPosition(infoX, infoY);
      var swell1Data = infoBox.get("#swell1Data")[0];
      swell1Data.setText(dataPoint.swell1);
      var swell2Data = infoBox.get("#swell2Data")[0];
      swell2Data.setText(dataPoint.swell2);
      var windData = infoBox.get("#windData")[0];
      windData.setText(dataPoint.wind);
    }

    this.mouseOverLayer.draw();
  }

  SurfForecast.prototype.surfMouseOutHandler = function() {
    // hide circle on mouse out
    /*
    var circle = this.mouseOverLayer.get("#circle");
    if (!circle) {
      circle.hide();
      this.mouseOverLayer.draw();
    }
    */
    this.mouseOverLayer.hide();

  }

  SurfForecast.prototype.generateBackground = function() {
    // Build the background rectangle
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: 709,
      height: 60,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    rect.setCornerRadius(7);
    this.backgroundLayer.add(rect);
    rect = new Kinetic.Rect({
      x: 0,
      y: 50,
      width: 709,
      height: 116,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    this.backgroundLayer.add(rect);

    // Build the surrounding rectangle
    rect = new Kinetic.Rect({
        x: this.graphLeft,
        y: 23.5,
        width: this.graphWidth,
        height: this.graphHeight,
        stroke: "#969696",
        fill: "#ffffff",
        strokeWidth: 1
    });
    this.backgroundLayer.add(rect);

    // Create the mouse over box
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: this.graphWidth,
      height: this.graphHeight,
    });
    rect.on('mouseout', $.proxy(this.surfMouseOutHandler, this));
    rect.on('mousemove', $.proxy(this.surfMouseOverHandler, this));
    this.mouseOverGroup.add(rect);
    this.mouseOverControlLayer.add(this.mouseOverGroup);
    this.mouseOverControlLayer.draw();


    // Build the day seperators
    var points, sunSetIndex, days = 0;
    for (var i = 0; i < this.data.length; i++) {
      if (this.data[i].hour === "12am") {
        points = []
        var x = this._getPointNear((i * this.dataColumnWidth) + this.graphLeft);
        points.push(x);
        points.push(this.graphTop);
        points.push(x);
        points.push(this.graphBottom);
        var daySeperatorLine = new Kinetic.Line({
          points: points,
          stroke: '#d9d9d9',
          strokeWidth: 1
        });
        this.backgroundLayer.add(daySeperatorLine);

        // Create the Day labels
        if (days < 6) {
          points = [];
          points.push(x);
          points.push(1);
          points.push(x);
          points.push(21);
          var labelSeperatorLine = new Kinetic.Line({
            points: points,
            stroke: '#ffffff',
            strokeWidth: 1
          });
          this.backgroundLayer.add(labelSeperatorLine);

          var dayLabelText = new Kinetic.Text({
            x: x + 12,
            y: 6,
            text: this.data[i].dayName + " " + this.data[i].month + "-" + this.data[i].day,
            textFill: "#064a77",
            fontFamily: 'Verdana',
            fontStyle: 'bold',
            fontSize: 9
          });
          this.backgroundLayer.add(dayLabelText);

          days++;
        }
      }


      // Build the dark rectangles
      if (this.data[i].hour == this.sunSetHour) {
        sunSetIndex = i;
      }

      if (this.data[i].hour == this.sunRiseHour && sunSetIndex) {
        rect = new Kinetic.Rect ({
          x: this._getPointNear((sunSetIndex * this.dataColumnWidth) + this.graphLeft),
          y: this.graphTop,
          width: Math.floor((i - sunSetIndex) * this.dataColumnWidth),
          height: this.graphBottom - this.graphTop,
          stroke: "#eeeeee",
          fill: "#eeeeee",
          strokeWidth: 1
        });
        this.backgroundLayer.add(rect);
        rect.setZIndex(rect.getZIndex() - 3);
      }
    }
  }

  SurfForecast.prototype.generateSurfBackground = function(direction) {
    this.generateBackground();

    // Build the legend below the chart
    var rect = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.backgroundLayer.add(rect);

    var labelText = new Kinetic.Text({
      x: 4.5,
      y: this.graphBottom + 8,
      textFill: "#0E4A75",
      text: "Forecast Updated: " + this.surfDataUpdated,
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Clean Rect
    rect = new Kinetic.Rect({
      x: 226,
      y: 150,
      width: 24,
      height: 8,
      fill: "#6ddc5d"
    });
    this.backgroundLayer.add(rect);

    // Clean Label
    labelText = new Kinetic.Text({
      x: 255,
      y: 150,
      textFill: "#0E4A75",
      text: "Clean",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Fair Rect
    rect = new Kinetic.Rect({
      x: 312,
      y: 150,
      width: 24,
      height: 8,
      fill: "#5d68ff"
    });
    this.backgroundLayer.add(rect);
    
    // Fair Label
    labelText = new Kinetic.Text({
      x: 341,
      y: 150,
      textFill: "#0E4A75",
      text: "Fair",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Choppy Rect
    rect = new Kinetic.Rect({
      x: 387,
      y: 150,
      width: 24,
      height: 8,
      fill: "#fe6a63"
    });
    this.backgroundLayer.add(rect);
    
    // Choppy Label
    labelText = new Kinetic.Text({
      x: 416,
      y: 150,
      textFill: "#0E4A75",
      text: "Choppy",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Direction Label
    labelText = new Kinetic.Text({
      id: "beachDirectionLabel",
      x: 479,
      y: 150,
      textFill: "#0E4A75",
      text: "Beach Direction: ",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Directions
    for (var i = 0; i < this.locationDirs.length; i++) {
      var buttonGroup = new Kinetic.Group({
        id: this.locationDirs[i],
        name: "directionButtonGroup",
        x: 576.5 + (i * 39),
        y: 146.5,
        width: 29,
        height: 14
      });
      if (this.locationDirs[i] == direction) {
        // Beach Direction Button
        rect = new Kinetic.Rect({
          name: this.locationDirs[i],
          fill: "#646464",
          stroke: "#FFFFFF",
          strokeWidth: 1,
          width: 29,
          height: 14
        });
        // Beach Direction Button Text
        labelText = new Kinetic.Text({
          name: this.locationDirs[i],
          y: 3,
          text: this.locationDirs[i],
          textFill: '#ffffff',
          width: 29,
          align: 'center',
          fontFamily: 'Verdana',
          fontSize: 7
        });
      } else {
        rect = new Kinetic.Rect({
          name: this.locationDirs[i],
          fill: "#FFFFFF",
          stroke: "#646464",
          strokeWidth: 1,
          width: 29,
          height: 14
        });
        labelText = new Kinetic.Text({
          name: this.locationDirs[i],
          y: 3,
          text: this.locationDirs[i],
          textFill: '#646464',
          width: 29,
          //height: 12,
          //lineHeight: 12,
          align: 'center',
          fontFamily: 'Verdana',
          fontSize: 7
        });
      }
      buttonGroup.add(rect);
      buttonGroup.add(labelText);
      buttonGroup.on("mouseover", $.proxy(this.directionButtonMouseOverHandler, this));
      buttonGroup.on("mouseout", $.proxy(this.directionButtonMouseOutHandler, this));
      buttonGroup.on("click", $.proxy(this.directionButtonClickHandler, this));
      this.backgroundLayer.add(buttonGroup);
    }



    // Build the Y Axis Labels and dashed lines
    var dashedDrawFunction = function(canvas) {
      // This function draws a horizontal dashed line so it cheats
      var points = this.attrs.points;
      var dashArray = this.attrs.dashArray;

      // Initial points are the first two entries. y won't change on a horizontal line
      var x = points[0].x;
      var y = points[0].y;

      var dashLength = dashArray[0];
      var gapLength = dashArray[1];

      // Cheating here. The length of the line is the difference in the x axis
      var length = points[1].x - points[0].x;
      var currentLength = 0;


      // Start drawing the line
      var context = canvas.getContext();
      context.beginPath();
      context.moveTo(x, y);

      while ((currentLength + dashLength + gapLength) < length) {
        context.lineTo(x + dashLength + currentLength, y);
        currentLength += dashLength;

        context.moveTo(x + gapLength + currentLength, y);
        currentLength += gapLength;
      }

      // end the line
      context.lineTo(x + dashLength + currentLength, y);

      canvas.fillStroke(this);
    }

    var yMaxValue = this.surfVerticalDataPoints;
    var yMinValue = 0;
    var datapointHeight = this.graphHeight / (yMaxValue - yMinValue);

    var labels = ["D-OH", "O-Head", "Head", "Shoulder", "Chest", "Waist", "Knee"];
    
    for (var i = 1; i < 8; i++) {
      var y = this._getPointNear(this.graphTop + (i * datapointHeight * 10));
      var dashedLine = new Kinetic.Line({
        drawFunc: dashedDrawFunction,
        stroke: '#d6d6d6',
        strokeWidth: 1,
        points: [45.5, y, 684.5, y],
        dashArray: [11, 14]
      });
      this.backgroundLayer.add(dashedLine);

      // Draw the Major Tick
      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [20.5, y, 29.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [698.5, y, 708.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      // Draw the Left Tick Labels
      var labelText = new Kinetic.Text({
        x: 33.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);

      // Draw the Right Tick Labels
      labelText = new Kinetic.Text({
        x: 640.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);
    }


    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.selectBackgroundButton = function(direction) {
    var buttonGroups = this.backgroundLayer.get(".directionButtonGroup");

    for (var i = 0; i < buttonGroups.length; i++) {
      if (buttonGroups[i].getId() == direction) {
        this.selectedDirectionButton(buttonGroups[i]);
      } else {
        this.unselectedDirectionButton(buttonGroups[i]);
      }
    }
  }

  SurfForecast.prototype.directionButtonMouseOverHandler = function(evt) {
    var shape = evt.shape;

    // get button text and background
    this.selectedDirectionButton(this.backgroundLayer.get("#" + shape.getName())[0]);
  }

  SurfForecast.prototype.selectedDirectionButton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#FFFFFF");
        buttons[i].setFill("#646464");
      } else {
        buttons[i].setTextFill("#FFFFFF");
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.unselectedDirectionButton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#646464");
        buttons[i].setFill("#FFFFFF");
      } else {
        buttons[i].setTextFill("#646464");
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.directionButtonMouseOutHandler = function(evt) {
    var shape = evt.shape;
    var direction = shape.getName();

    // get button text and background
    if (this.beachDirection != direction) {
      this.unselectedDirectionButton(this.backgroundLayer.get("#" + shape.getName())[0]);
    }
  }

  SurfForecast.prototype.directionButtonClickHandler = function(evt) {
    var shape = evt.shape;
    var direction = shape.getName();

    this.beachDirection = direction;
    this.fetchData(direction);
  }

  return SurfForecast;
})();


$(document).ready(function() {
  if ($("#surf_forecast").length > 0) {
    new SurfForecast({
      locationDir: "SSE||SE",
      beachDir: "SE",
      locationKey: "wna_nj_oceancity",
      srise: "7:17",
      sset: "4:42",
    });
  }
});
