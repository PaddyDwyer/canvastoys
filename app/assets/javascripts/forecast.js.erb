<% environment.context_class.instance_eval {include Rails.application.routes.url_helpers } %>
var SurfForecastData= (function() {
  SurfForecastData.name = "SurfForecastData";

  function SurfForecastData(data) {
    var dataPoints = data.getElementsByTagName("data");
    this.surfDataUpdated = data.documentElement.getAttribute("update");
    this.dataPoints = [];
    var firstDataPoint;
    for (var i = 0; i < dataPoints.length; i++) {
      var dataPoint = new SurfForecastDataPoint(dataPoints[i]);
      if (!firstDataPoint) {
        firstDataPoint = dataPoint;
      }
      if (dataPoint.day == firstDataPoint.day + 7 && dataPoint.hour == firstDataPoint.hour ) {
        break;
      } else {
        this.dataPoints.push(dataPoint);
      }
    }
  }

  return SurfForecastData;
})();

var SurfForecastDataPoint = (function() {
  SurfForecastDataPoint.name = "SurfForecastDataPoint";

  function SurfForecastDataPoint(dataElement) {
    this.day = ("0" + dataElement.getAttribute("day")).substr(-2);
    this.hour = dataElement.getAttribute("hour");
    this.dayName = dataElement.getAttribute("day_name");
    this.month = dataElement.getAttribute("month");
    this.surf = parseInt(dataElement.getAttribute("surf"), 10);
    this.cond = dataElement.getAttribute("cond");
    this.swell1 = dataElement.getAttribute("swell1");
    this.swell2 = dataElement.getAttribute("swell2");
    this.wind = dataElement.getAttribute("wind");
  }

  return SurfForecastDataPoint;
})();

var SwellForecastData = (function() {
  SwellForecastData.name = "SwellForecastData";

  function SwellForecastData(data) {
    var dataPoints = data.getElementsByTagName("data");
    this.dataPoints = [];
    for (var i = 0; i < dataPoints.length; i++) {
      var dataPoint = new SwellForecastDataPoint(dataPoints[i]);
      this.dataPoints.push(dataPoint);
    }
  }

  SwellForecastData.prototype.getMaxHeight = function() {
    var maxHeight = 0;
    for (var i = 0; i < this.dataPoints.length; i++) {
      var dataPoint = this.dataPoints[i];
      for (var j = 0; j < dataPoint.heights.length; j++) {
        if (dataPoint.heights[j] > maxHeight) {
          maxHeight = dataPoint.heights[j];
        }
      }
    }
    return maxHeight;
  }

  return SwellForecastData;
})();

var SwellForecastDataPoint = (function() {
  SwellForecastDataPoint.name = "SwellForecastDataPoint";

  function SwellForecastDataPoint(dataElement) {
    this.day = ("0" + dataElement.getAttribute("day")).substr(-2);
    this.hour = dataElement.getAttribute("hour");
    this.dayName = dataElement.getAttribute("day_name");
    this.month = dataElement.getAttribute("month");
    this.heights = [];
    for (var i = 0; i < 6; i++) {
      this.heights.push(parseFloat(dataElement.getAttribute("ht" + i)));
    }
  }

  return SwellForecastDataPoint;
})();

var SurfForecast = (function() {
  SurfForecast.name = "SurfForecast";

  // Constructor. Takes an options object which sets up the Surf Forecast.
  function SurfForecast(options) {
    // Create the kinetic stage we'll use to draw everything
    this.stage = new Kinetic.Stage({container: "surf_forecast", width: 709, height: 166});

    // Surf Data url is where we get the surf forecast data from
    this.locationDirs = options.locationDir.split("||");
    var locationKey = options.locationKey;

    this.filenames = {};
    this.filenames[this.locationDirs[0]] = locationKey;

    for (var i = 1; i < this.locationDirs.length; i++) {
      this.filenames[this.locationDirs[i]] = locationKey + "_" + this.locationDirs[i].toLowerCase();
    }

    // Beach Direction
    this.beachDirection = options.beachDir;

    // Set up initial properties for Sunrise
    this.sunSetHour = options.sset.substring(0, 1) + "pm";
    this.sunRiseHour = options.srise.substring(0, 1) + "am";
    this.baseLayer = new Kinetic.Layer();
    this.backgroundLayer = new Kinetic.Layer();
    this.foregroundLayer = new Kinetic.Layer();
    this.mouseOverLayer = new Kinetic.Layer();
    var mouseOverTimeWhiteBackground = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.mouseOverLayer.add(mouseOverTimeWhiteBackground);
    this.mouseOverLayer.hide();
    this.mouseOverControlLayer = new Kinetic.Layer();
    this.graphWidth = 689;
    this.graphHeight = 119;
    this.graphLeft = 19.5;
    this.graphRight = this.graphLeft + this.graphWidth;
    this.graphTop = 24.5;
    this.graphBottom = 141.5;
    this.surfVerticalDataPoints = 80;
    this.mouseOverGroup = new Kinetic.Group({
      x: this.graphLeft,
      y: this.graphTop
    });

    this.stage.add(this.baseLayer);
    this.stage.add(this.backgroundLayer);
    this.stage.add(this.foregroundLayer);
    this.stage.add(this.mouseOverLayer);
    this.stage.add(this.mouseOverControlLayer);

    this.selectedForecast = "surfButton";
    this.fetchSurfData();
  }

  // Private method used to get the point at the nearest 0.5. Canvas horizontal and vertical
  // lines don't look well defined at 1px unless they have a .5 in them.
  SurfForecast.prototype._getPointNear = function(point) {
    return Math.round(point + 0.5) - 0.5;
  }

  // Ajax call to get the surf forecast data
  SurfForecast.prototype.fetchSurfData = function(direction) {
    direction = direction || this.beachDirection;
    _this = this;
    var basePath = "<%= data_timelines_path %>/";
    $.ajax(basePath + this.filenames[direction] + ".xml", {
      success: function(data, textStatus, xhr) {
        _this.bindSurfData(data, textStatus, xhr, direction);
      },
      cache: false
    });
  }

  SurfForecast.prototype.fetchSwellData = function() {
    _this = this;
    var basePath = "<%= data_bull_xmls_path %>/";
    $.ajax(basePath + this.filenames[this.locationDirs[0]] + ".xml", {
      success: $.proxy(this.bindSwellData, this),
      cache: false
    });
  }

  // Binds data to the surf forecast and sets up various utility data points
  SurfForecast.prototype.bindSurfData = function(data, textStatus, xhr, direction) {
    this.data = new SurfForecastData(data);

    //this.data = surfForecastDataArray;
    this.dataColumnWidth = this.graphWidth / this.data.dataPoints.length;
    this.surfDataHeight = this.graphHeight / this.surfVerticalDataPoints;

    if (this.backgroundLayer.get("#beachDirectionLabel").length > 0) {
      this.updateSurfBackground(direction);
    } else {
      this.generateSurfBackground(direction);
    }
    this.generateSurfForeground();
  }

  SurfForecast.prototype.bindSwellData = function(data, textStatus, xhr) {
    this.selectedForecast = "swellButton";

    this.data = new SwellForecastData(data);

    /*
    */
    //this.dataColumnWidth = this.graphWidth / this.data.length;
    //this.surfDataHeight = this.graphHeight / this.surfVerticalDataPoints;

    this.generateSwellBackground();
    this.generateSwellForeground();
  }

  SurfForecast.prototype.generateSwellBackground = function() {
    this.updateBaseLayer();
    this.backgroundLayer.removeChildren();

    // Build the legend below the chart
    var labelText = new Kinetic.Text({
      x: 4.5,
      y: this.graphBottom + 8,
      textFill: "#383838",
      text: "Click swell color for roll over details",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);
    
    // Swell 1 Rect
    var rect = new Kinetic.Rect({
      x: 220,
      y: 149,
      width: 24,
      height: 8,
      fill: "#fe1d00"
    });
    this.backgroundLayer.add(rect);

    // Swell 1 Label
    labelText = new Kinetic.Text({
      x: 250,
      y: 150,
      textFill: "#383838",
      text: "Swell 1",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Swell 2 Rect
    var rect = new Kinetic.Rect({
      x: 301,
      y: 149,
      width: 24,
      height: 8,
      fill: "#0016FF"
    });
    this.backgroundLayer.add(rect);

    // Swell 2 Label
    labelText = new Kinetic.Text({
      x: 331,
      y: 150,
      textFill: "#383838",
      text: "Swell 2",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Swell 3 Rect
    var rect = new Kinetic.Rect({
      x: 382,
      y: 149,
      width: 24,
      height: 8,
      fill: "#2B8A13"
    });
    this.backgroundLayer.add(rect);

    // Swell 3 Label
    labelText = new Kinetic.Text({
      x: 412,
      y: 150,
      textFill: "#383838",
      text: "Swell 3",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Swell 4 Rect
    var rect = new Kinetic.Rect({
      x: 463,
      y: 149,
      width: 24,
      height: 8,
      fill: "#DA7393"
    });
    this.backgroundLayer.add(rect);

    // Swell 4 Label
    labelText = new Kinetic.Text({
      x: 493,
      y: 150,
      textFill: "#383838",
      text: "Swell 4",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Swell 5 Rect
    var rect = new Kinetic.Rect({
      x: 544,
      y: 149,
      width: 24,
      height: 8,
      fill: "#15FEFF"
    });
    this.backgroundLayer.add(rect);

    // Swell 5 Label
    labelText = new Kinetic.Text({
      x: 574,
      y: 150,
      textFill: "#383838",
      text: "Swell 5",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);


    // Swell 6 Rect
    var rect = new Kinetic.Rect({
      x: 625,
      y: 149,
      width: 24,
      height: 8,
      fill: "#FFA600"
    });
    this.backgroundLayer.add(rect);

    // Swell 6 Label
    labelText = new Kinetic.Text({
      x: 655,
      y: 150,
      textFill: "#383838",
      text: "Swell 6",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);


    // Build the Y Axis Labels and dashed lines
    // Get the Max Height
    var maxHeight = Math.ceil(this.data.getMaxHeight()) + 1;
    var scale = false;
    var tickOptions = [3, 4, 5];
    var ticks;
    while (scale == false) {
      for (var i = 0; i < tickOptions.length; i++) {
        if (maxHeight % tickOptions[i] == 0) {
          ticks = tickOptions[i];
          scale = true;
        }
      }
      maxHeight++;
    }
    if (scale) {
      var tickInt = (maxHeight - 1) / ticks;
      this.swellDataHeight = this.graphHeight / (maxHeight - 1);
      var tickLabels = [];
      for (var i = ticks - 1; i > 0; i--) {
        tickLabels.push((i * tickInt) + " ft");
      }
      for (var i = 1; i < ticks; i++) {
        var y = this._getPointNear(this.graphTop + (i * tickInt * this.swellDataHeight));
        // Draw the dashed line
        var dashedLine = new Kinetic.Line({
          drawFunc: dashedDrawFunction,
          stroke: '#d6d6d6',
          strokeWidth: 1,
          points: [45.5, y, 684.5, y],
          dashArray: [11, 14]
        });
        this.backgroundLayer.add(dashedLine);

        // Draw the left labels
        var labelText = new Kinetic.Text({
          x: 33.5,
          y: y - 4,
          textFill: "#0E4A75",
          text: tickLabels[i - 1],
          fontFamily: 'Verdana',
          fontSize: 8
        });
        this.backgroundLayer.add(labelText);

        // Draw the right labels
        labelText = new Kinetic.Text({
          x: 640.5,
          y: y - 4,
          textFill: "#6d87a6",
          text: tickLabels[i - 1],
          fontFamily: 'Verdana',
          fontSize: 8
        });
        this.backgroundLayer.add(labelText);

        // Draw the major ticks
        var majorTickLine = new Kinetic.Line({
          stroke: '#003366',
          strokeWidth: 1,
          points: [20.5, y, 29.5, y]
        });
        this.backgroundLayer.add(majorTickLine);

        var majorTickLine = new Kinetic.Line({
          stroke: '#003366',
          strokeWidth: 1,
          points: [698.5, y, 708.5, y]
        });
        this.backgroundLayer.add(majorTickLine);
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.generateSwellForeground = function() {
    this.foregroundLayer.removeChildren();

    // do the red line
    var colors = ["#FE1D00", "#0016FF", "#2B8A13", "#DA7393", "#15FEFF", "#FFA600"];
    var points = [ [], [], [], [], [], [] ], x, y;
    for (var i = 0; i < this.data.dataPoints.length; i++) {
      var dataPoint = this.data.dataPoints[i];
      console.log(dataPoint.dayName, dataPoint.hour, dataPoint.heights[2]);
      for (var j = 0; j < dataPoint.heights.length; j++) {
        x = (i * this.dataColumnWidth) + this.graphLeft;
        y = this.graphBottom - (dataPoint.heights[j] * this.swellDataHeight);

        // Only add points to a line if they have a high enough height
        if (dataPoint.heights[j] > 0.7) {
          // Start a new line
          if (!points[j]) {
            points[j] = [{x: x, y: y}];
          } else { // continue line
            points[j].push({x: x, y: y});
          }
        }

        // Check to see if we need to end a line
        if (dataPoint.heights[j] < 0.7 || i == this.data.dataPoints.length - 1)  { 
          // Need 2 points to make a line
          if (points[j] && points[j].length > 1) {
            var redLine = new Kinetic.Line({
              points: points[j],
              stroke: colors[j],
              strokeWidth: 1
            });
            this.foregroundLayer.add(redLine);
          }
          // Reset redPoints whenever there is no valid value because there 
          // may be 1 point in the array
          points[j] = null;
          if (j == 2) {
            console.log("resetting");
          }
        }
      }
    }


    this.foregroundLayer.draw();
  }

  SurfForecast.prototype.generateSurfForeground = function() {
    this.foregroundLayer.removeChildren();
    var _this = this;
    var fillConditionColors = {"0": "rgba(204, 204, 204, 0.3)",
      "1": "rgba(0, 200, 0, 0.3)",
      "2": "rgba(0, 0, 256, 0.3)",
      "3": "rgba(256, 0, 0, 0.3)"};
    var strokeConditionColors = {"0": "#CCCCCC",
      "1": "#00C800",
      "2": "#0000FF",
      "3": "#FF0000"};

    var lastCondition, lastPoint, fillPoints, fillColor, strokePoints, strokeColor, endLine;
    for (var i = 0; i < this.data.dataPoints.length;) {
      var dataPoint = this.data.dataPoints[i];

      // Start a new line
      if (lastPoint) {
        fillPoints = [((i - 1) * this.dataColumnWidth) + this.graphLeft, this.graphBottom];
        fillPoints = fillPoints.concat(lastPoint);
      } else {
        fillPoints = [(i * this.dataColumnWidth) + this.graphLeft, this.graphBottom];
      }
      fillColor = fillConditionColors[dataPoint.cond];
      strokePoints = lastPoint || [];
      strokeColor = strokeConditionColors[dataPoint.cond];

      // Add points of the same color to arrays
      lastCondition = dataPoint.cond
      while (dataPoint.cond == lastCondition && i < this.data.dataPoints.length) {
        dataPoint = this.data.dataPoints[i];
        x = (i * this.dataColumnWidth) + this.graphLeft;
        fillPoints.push(x);
        strokePoints.push(x);
        y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
        fillPoints.push(y);
        strokePoints.push(y);
        lastPoint = [x, y];


        i++;
      }

      // Extend the last data point out so the graph looks full
      if (i == this.data.dataPoints.length) {
        x = (i * this.dataColumnWidth) + this.graphLeft;
        fillPoints.push(x);
        strokePoints.push(x);
        y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
        fillPoints.push(y);
        strokePoints.push(y);

        // Add the bottom of the fill Poly
        fillPoints.push((i * this.dataColumnWidth) + this.graphLeft);
        fillPoints.push(this.graphBottom);
      } else {
        // If it's not the end of the graph we still need to add the bottom point of the 
        // fill poly
        fillPoints.push(((i - 1) * this.dataColumnWidth) + this.graphLeft);
        fillPoints.push(this.graphBottom);
      }

      // End the line
      var fillPoly = new Kinetic.Polygon({
        points: fillPoints,
          fill: fillColor
      });
      this.foregroundLayer.add(fillPoly);
      var strokeLine = new Kinetic.Line({
        points: strokePoints,
        stroke: strokeColor,
        strokeWidth: 1
      });
      this.foregroundLayer.add(strokeLine);
    }

    this.foregroundLayer.draw();
  }

  SurfForecast.prototype.surfMouseOverHandler = function() {
    var mousePosition = this.stage.getMousePosition();

    var mouseX = mousePosition.x;

    // get the data point
    var index = Math.round((mouseX - this.graphLeft) / this.dataColumnWidth);

    var dataPoint = this.data.dataPoints[index];

    var x = (index * this.dataColumnWidth) + this.graphLeft;
    var y = y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);


    this.mouseOverLayer.show();
    // Draw the data Point circle
    var circle = this.mouseOverLayer.get("#circle")[0];
    if (!circle) {
      circle = new Kinetic.Circle({
        id: "circle",
        x: x,
        y: y,
        radius: 2.5,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 1
      });
      this.mouseOverLayer.add(circle);
    } else {
      circle.show();
      circle.setPosition(x, y);
    }

    // Draw the Horizontal Line
    var horizontalLine = this.mouseOverLayer.get("#hline")[0];
    if ((x - this.graphLeft) < (this.graphWidth / 2)) {
      var points = [{x: this.graphLeft, y: y}, {x: x, y: y}];
    } else {
      var points = [{x: x, y: y}, {x: this.graphRight, y: y}];
    }
    if (!horizontalLine) {
      horizontalLine = new Kinetic.Line({
        id: "hline",
        points: points,
        stroke: "#000000",
        strokeWidth: 1
      });
      this.mouseOverLayer.add(horizontalLine);
    } else {
      horizontalLine.setPoints(points);
    }

    // Draw the Vertical Line
    var verticalLine = this.mouseOverLayer.get("#vline")[0];
    var points = [{x: x, y: this.graphBottom}, {x: x, y: y}];
    if (!verticalLine) {
      verticalLine = new Kinetic.Line({
        id: "vline",
        points: points,
        stroke: "#000000",
        strokeWidth: 1
      });
      this.mouseOverLayer.add(verticalLine);
    } else {
      verticalLine.setPoints(points);
    }

    // Draw the time label
    var timeLabel = this.mouseOverLayer.get("#timeLabel")[0];
    if (!timeLabel) {
      timeLabel = new Kinetic.Text({
        id: "timeLabel",
        x: x,
        y: this.graphBottom + 8,
        text: dataPoint.hour,
        textFill: "#000",
        fontFamily: 'Times',
        fontSize: 9
      });
      this.mouseOverLayer.add(timeLabel);
    } else {
      timeLabel.setText(dataPoint.hour);
      timeLabel.setPosition(x, this.graphBottom + 8);
    }

    // Draw the Info Box
    var infoBox = this.mouseOverLayer.get("#infoBox")[0];
    if ((x - this.graphLeft) < (this.graphWidth / 2)) {
      var infoX = x + 25;
    } else {
      var infoX = x - 173;
    }
    if ((y - this.graphTop) > (this.graphHeight / 2)) {
      var infoY = y - 47;
    } else {
      var infoY = y;
    }
    if (!infoBox) {
      infoBox = new Kinetic.Group({
        id: "infoBox",
        x: infoX,
        y: infoY,
      });
      var rect = new Kinetic.Rect({
        width: 148,
        height: 47,
        fill: "#000"
      });
      rect.setCornerRadius(6);
      infoBox.add(rect);

      var swellsLabel = new Kinetic.Text({
        x: 5,
        y: 5,
        text: "Swells:",
        textFill: "#FFFFCC",
        fontSize: 8,
        fontFamily: "Verdana"
      });
      infoBox.add(swellsLabel);

      var swells1Data = new Kinetic.Text({
        id: "swell1Data",
        x: 44,
        y: 5,
        textFill: "#FFFFFF",
        fontSize: 8,
        fontFamily: "Verdana",
        text: dataPoint.swell1
      });
      infoBox.add(swells1Data);
      var swells2Data = new Kinetic.Text({
        id: "swell2Data",
        x: 44,
        y: 20,
        textFill: "#FFFFFF",
        fontSize: 8,
        fontFamily: "Verdana",
        text: dataPoint.swell2
      });
      infoBox.add(swells2Data);

      var windLabel = new Kinetic.Text({
        x: 5,
        y: 34,
        text: "Wind:",
        textFill: "#FFFFCC",
        fontSize: 8,
        fontFamily: "Verdana"
      });
      infoBox.add(windLabel);

      var windData = new Kinetic.Text({
        id: "windData",
        x: 44,
        y: 34,
        textFill: "#FFFFFF",
        fontSize: 8,
        fontFamily: "Verdana",
        text: dataPoint.wind
      });
      infoBox.add(windData);
      this.mouseOverLayer.add(infoBox);
    } else {
      infoBox.setPosition(infoX, infoY);
      var swell1Data = infoBox.get("#swell1Data")[0];
      swell1Data.setText(dataPoint.swell1);
      var swell2Data = infoBox.get("#swell2Data")[0];
      swell2Data.setText(dataPoint.swell2);
      var windData = infoBox.get("#windData")[0];
      windData.setText(dataPoint.wind);
    }

    this.mouseOverLayer.draw();
  }

  SurfForecast.prototype.surfMouseOutHandler = function() {
    // hide circle on mouse out
    /*
    var circle = this.mouseOverLayer.get("#circle");
    if (!circle) {
      circle.hide();
      this.mouseOverLayer.draw();
    }
    */
    this.mouseOverLayer.hide();

  }

  SurfForecast.prototype.generateBackground = function() {
    // Build the background rectangle
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: 709,
      height: 60,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    rect.setCornerRadius(7);
    this.baseLayer.add(rect);
    rect = new Kinetic.Rect({
      x: 0,
      y: 50,
      width: 709,
      height: 116,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    this.baseLayer.add(rect);

    // Build the surrounding rectangle
    rect = new Kinetic.Rect({
        x: this.graphLeft,
        y: 23.5,
        width: this.graphWidth,
        height: this.graphHeight,
        stroke: "#969696",
        fill: "#ffffff",
        strokeWidth: 1
    });
    this.baseLayer.add(rect);

    // Create the mouse over box
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: this.graphWidth,
      height: this.graphHeight,
    });
    rect.on('mouseout', $.proxy(this.surfMouseOutHandler, this));
    rect.on('mousemove', $.proxy(this.surfMouseOverHandler, this));
    this.mouseOverGroup.add(rect);
    this.mouseOverControlLayer.add(this.mouseOverGroup);
    this.mouseOverControlLayer.draw();

    this.generateDaySeperators();

    // White Box for the legend
    var rect = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.baseLayer.add(rect);



    // Build Surf Button Group
    var buttonGroup = new Kinetic.Group({
      id: "surfButton",
      name: "forecastButtonGroup",
      x: 2.5,
      y: 81.5,
      rotationDeg: -90
    });

    rect = new Kinetic.Rect({
      name: "surfButton",
      width: 57,
      height: 15,
      fill: "#064a77",
      stroke: "#FFFFFF",
      strokeWidth: 1
    });
    buttonGroup.add(rect);

    var text = new Kinetic.Text({
      name: "surfButton",
      y: 4,
      width: 60,
      text: "SURF",
      textFill: "#FFFFFF",
      fontSize: 8,
      fontStyle: 'bold',
      fontFamily: 'Verdana',
      align: 'center'
    });
    buttonGroup.add(text);
    buttonGroup.on("mouseover", $.proxy(this.forecastButtonMouseOverHandler, this));
    buttonGroup.on("mouseout", $.proxy(this.forecastButtonMouseOutHandler, this));
    this.baseLayer.add(buttonGroup);

    // Build Swell Button Group
    buttonGroup = new Kinetic.Group({
      id: "swellButton",
      name: "forecastButtonGroup",
      x: 2.5,
      y: 141.5,
      rotationDeg: -90
    });

    rect = new Kinetic.Rect({
      name: "swellButton",
      width: 58,
      height: 15,
      stroke: "#064a77",
      fill: "#FFFFFF",
      strokeWidth: 1
    });
    buttonGroup.add(rect);

    var text = new Kinetic.Text({
      name: "swellButton",
      y: 4,
      width: 60,
      text: "SWELLS",
      textFill: "#064a77",
      fontSize: 8,
      fontStyle: 'bold',
      fontFamily: 'Verdana',
      align: 'center'
    });
    buttonGroup.add(text);
    buttonGroup.on("mouseover", $.proxy(this.forecastButtonMouseOverHandler, this));
    buttonGroup.on("mouseout", $.proxy(this.forecastButtonMouseOutHandler, this));
    buttonGroup.on("click", $.proxy(this.forecastButtonClickHandler, this));
    this.baseLayer.add(buttonGroup);
    this.baseLayer.draw();
  }

  SurfForecast.prototype.generateDaySeperators = function() {
    var daySeperatorGroup = this.baseLayer.get("#daySeperatorGroup")[0];

    if (!daySeperatorGroup) {
      var daySeperatorGroup = new Kinetic.Group({
        id: "daySeperatorGroup"
      });
    }
    daySeperatorGroup.removeChildren();
    // Build the day seperators
    var points, sunSetIndex, days = 0;
    for (var i = 0; i < this.data.dataPoints.length; i++) {
      if (this.data.dataPoints[i].hour === "12am") {
        points = []
        var x = this._getPointNear((i * this.dataColumnWidth) + this.graphLeft);
        points.push(x);
        points.push(this.graphTop);
        points.push(x);
        points.push(this.graphBottom);
        var daySeperatorLine = new Kinetic.Line({
          points: points,
          stroke: '#d9d9d9',
          strokeWidth: 1
        });
        daySeperatorGroup.add(daySeperatorLine);

        // Create the Day labels
        if (days < 6) {
          points = [];
          points.push(x);
          points.push(1);
          points.push(x);
          points.push(21);
          var labelSeperatorLine = new Kinetic.Line({
            points: points,
            stroke: '#ffffff',
            strokeWidth: 1
          });
          daySeperatorGroup.add(labelSeperatorLine);

          var dayLabelText = new Kinetic.Text({
            x: x,
            y: 8,
            text: this.data.dataPoints[i].dayName + " " + this.data.dataPoints[i].month + "-" + this.data.dataPoints[i].day,
            textFill: "#064a77",
            fontFamily: 'Verdana',
            fontStyle: 'bold',
            fontSize: 8,
            align: 'center',
            width: this.dataColumnWidth * 24,
          });
          daySeperatorGroup.add(dayLabelText);

          days++;
        }
      }


      // Build the dark rectangles
      if (this.data.dataPoints[i].hour == this.sunSetHour) {
        sunSetIndex = i;
      }

      if (this.data.dataPoints[i].hour == this.sunRiseHour && sunSetIndex) {
        rect = new Kinetic.Rect ({
          x: this._getPointNear((sunSetIndex * this.dataColumnWidth) + this.graphLeft),
          y: this.graphTop,
          width: Math.floor((i - sunSetIndex) * this.dataColumnWidth),
          height: this.graphBottom - this.graphTop,
          stroke: "#eeeeee",
          fill: "#eeeeee",
          strokeWidth: 1
        });
        daySeperatorGroup.add(rect);
        rect.setZIndex(rect.getZIndex() - 3);
      }
    }
    this.baseLayer.add(daySeperatorGroup);

  }

  SurfForecast.prototype.generateSurfBackground = function(direction) {
    this.generateBackground();

    // Build the legend below the chart
    var labelText = new Kinetic.Text({
      x: 4.5,
      y: this.graphBottom + 8,
      textFill: "#383838",
      text: "Forecast Updated: " + this.surfDataUpdated,
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Clean Rect
    var rect = new Kinetic.Rect({
      x: 226,
      y: 150,
      width: 24,
      height: 8,
      fill: "#6ddc5d"
    });
    this.backgroundLayer.add(rect);

    // Clean Label
    labelText = new Kinetic.Text({
      x: 255,
      y: 150,
      textFill: "#383838",
      text: "Clean",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Fair Rect
    rect = new Kinetic.Rect({
      x: 312,
      y: 150,
      width: 24,
      height: 8,
      fill: "#5d68ff"
    });
    this.backgroundLayer.add(rect);
    
    // Fair Label
    labelText = new Kinetic.Text({
      x: 341,
      y: 150,
      textFill: "#383838",
      text: "Fair",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Choppy Rect
    rect = new Kinetic.Rect({
      x: 387,
      y: 150,
      width: 24,
      height: 8,
      fill: "#fe6a63"
    });
    this.backgroundLayer.add(rect);
    
    // Choppy Label
    labelText = new Kinetic.Text({
      x: 416,
      y: 150,
      textFill: "#383838",
      text: "Choppy",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Direction Label
    labelText = new Kinetic.Text({
      id: "beachDirectionLabel",
      x: 479,
      y: 150,
      textFill: "#383838",
      text: "Beach Direction: ",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Directions
    for (var i = 0; i < this.locationDirs.length; i++) {
      var buttonGroup = new Kinetic.Group({
        id: this.locationDirs[i],
        name: "directionButtonGroup",
        x: 576.5 + (i * 39),
        y: 146.5,
        width: 29,
        height: 14
      });
      if (this.locationDirs[i] == direction) {
        // Beach Direction Button
        rect = new Kinetic.Rect({
          name: this.locationDirs[i],
          fill: "#646464",
          stroke: "#FFFFFF",
          strokeWidth: 1,
          width: 29,
          height: 14
        });
        // Beach Direction Button Text
        labelText = new Kinetic.Text({
          name: this.locationDirs[i],
          y: 3,
          text: this.locationDirs[i],
          textFill: '#ffffff',
          width: 29,
          align: 'center',
          fontFamily: 'Verdana',
          fontSize: 7
        });
      } else {
        rect = new Kinetic.Rect({
          name: this.locationDirs[i],
          fill: "#FFFFFF",
          stroke: "#646464",
          strokeWidth: 1,
          width: 29,
          height: 14
        });
        labelText = new Kinetic.Text({
          name: this.locationDirs[i],
          y: 3,
          text: this.locationDirs[i],
          textFill: '#646464',
          width: 29,
          //height: 12,
          //lineHeight: 12,
          align: 'center',
          fontFamily: 'Verdana',
          fontSize: 7
        });
      }
      buttonGroup.add(rect);
      buttonGroup.add(labelText);
      buttonGroup.on("mouseover", $.proxy(this.directionButtonMouseOverHandler, this));
      buttonGroup.on("mouseout", $.proxy(this.directionButtonMouseOutHandler, this));
      buttonGroup.on("click", $.proxy(this.directionButtonClickHandler, this));
      this.backgroundLayer.add(buttonGroup);
    }



    // Build the Y Axis Labels and dashed lines
    var yMaxValue = this.surfVerticalDataPoints;
    var yMinValue = 0;
    var datapointHeight = this.graphHeight / (yMaxValue - yMinValue);

    var labels = ["D-OH", "O-Head", "Head", "Shoulder", "Chest", "Waist", "Knee"];
    
    for (var i = 1; i < 8; i++) {
      var y = this._getPointNear(this.graphTop + (i * datapointHeight * 10));
      var dashedLine = new Kinetic.Line({
        drawFunc: dashedDrawFunction,
        stroke: '#d6d6d6',
        strokeWidth: 1,
        points: [45.5, y, 684.5, y],
        dashArray: [11, 14]
      });
      this.backgroundLayer.add(dashedLine);

      // Draw the Major Tick
      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [20.5, y, 29.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [698.5, y, 708.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      // Draw the Left Tick Labels
      var labelText = new Kinetic.Text({
        x: 33.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);

      // Draw the Right Tick Labels
      labelText = new Kinetic.Text({
        x: 640.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);
    }


    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.updateSurfBackground = function(direction) {
    this.updateBaseLayer();


    // Update the surf direction buttons
    var buttonGroups = this.backgroundLayer.get(".directionButtonGroup");

    for (var i = 0; i < buttonGroups.length; i++) {
      if (buttonGroups[i].getId() == direction) {
        this.selectedDirectionButton(buttonGroups[i]);
      } else {
        this.unselectedDirectionButton(buttonGroups[i]);
      }
    }
  }

  SurfForecast.prototype.updateBaseLayer = function() {
    // Redraw the timeline
    this.generateDaySeperators();

    var buttonGroups = this.baseLayer.get(".forecastButtonGroup");
    for (var i = 0; i < buttonGroups.length; i++) {
      if (buttonGroups[i].getId() == this.selectedForecast) {
        this.selectedForecastbutton(buttonGroups[i]);
      } else {
        this.unselectedForecastButton(buttonGroups[i]);
      }
    }

    this.baseLayer.draw();
  }

  SurfForecast.prototype.forecastButtonMouseOverHandler = function(evt) {
    var shape = evt.shape;
    var group = this.baseLayer.get("#" + shape.getName())[0];

    this.selectedForecastbutton(group);

    this.baseLayer.draw();
  }

  SurfForecast.prototype.forecastButtonMouseOutHandler = function(evt) {
    var shape = evt.shape;
    if (this.selectedForecast != shape.getName()) {
      var group = this.baseLayer.get("#" + shape.getName())[0];
      this.unselectedForecastButton(group);
    }

    this.baseLayer.draw();
  }

  SurfForecast.prototype.forecastButtonClickHandler = function(evt) {
    var shape = evt.shape;

    //this.foregroundLayer.removeChildren();
    //this.foregroundLayer.draw();

    this.fetchSwellData();
  }

  SurfForecast.prototype.selectedForecastbutton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#FFFFFF");
        buttons[i].setFill("#064a77");
      } else {
        buttons[i].setTextFill("#FFFFFF");
      }
    }
  }

  SurfForecast.prototype.unselectedForecastButton = function(group) {
      var buttons = group.getChildren();
      for (var i = 0; i < buttons.length; i++) {
        if (buttons[i].shapeType == "Rect") {
          buttons[i].setStroke("#064a77");
          buttons[i].setFill("#FFFFFF");
        } else {
          buttons[i].setTextFill("#064a77");
        }
      }
  }

  SurfForecast.prototype.directionButtonMouseOverHandler = function(evt) {
    var shape = evt.shape;

    // get button text and background
    this.selectedDirectionButton(this.backgroundLayer.get("#" + shape.getName())[0]);
  }

  SurfForecast.prototype.selectedDirectionButton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#FFFFFF");
        buttons[i].setFill("#646464");
      } else {
        buttons[i].setTextFill("#FFFFFF");
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.unselectedDirectionButton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#646464");
        buttons[i].setFill("#FFFFFF");
      } else {
        buttons[i].setTextFill("#646464");
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.directionButtonMouseOutHandler = function(evt) {
    var shape = evt.shape;
    var direction = shape.getName();

    // get button text and background
    if (this.beachDirection != direction) {
      this.unselectedDirectionButton(this.backgroundLayer.get("#" + shape.getName())[0]);
    }
  }

  SurfForecast.prototype.directionButtonClickHandler = function(evt) {
    var shape = evt.shape;
    var direction = shape.getName();

    this.beachDirection = direction;
    this.fetchSurfData(direction);
  }

  var dashedDrawFunction = function(canvas) {
    // This function draws a horizontal dashed line so it cheats
    var points = this.attrs.points;
    var dashArray = this.attrs.dashArray;

    // Initial points are the first two entries. y won't change on a horizontal line
    var x = points[0].x;
    var y = points[0].y;

    var dashLength = dashArray[0];
    var gapLength = dashArray[1];

    // Cheating here. The length of the line is the difference in the x axis
    var length = points[1].x - points[0].x;
    var currentLength = 0;


    // Start drawing the line
    var context = canvas.getContext();
    context.beginPath();
    context.moveTo(x, y);

    while ((currentLength + dashLength + gapLength) < length) {
      context.lineTo(x + dashLength + currentLength, y);
      currentLength += dashLength;

      context.moveTo(x + gapLength + currentLength, y);
      currentLength += gapLength;
    }

    // end the line
    context.lineTo(x + dashLength + currentLength, y);

    canvas.fillStroke(this);
  }


  return SurfForecast;
})();


$(document).ready(function() {
  if ($("#surf_forecast").length > 0) {
    new SurfForecast({
      locationDir: "SSE||SE",
      beachDir: "SE",
      locationKey: "wna_nj_oceancity",
      srise: "7:17",
      sset: "4:42",
    });
  }
});
