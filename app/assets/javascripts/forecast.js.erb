var SurfForecastData = (function() {
  SurfForecastData.name = "SurfForecastData";

  function SurfForecastData(dataElement) {
    this.day = parseInt(dataElement.getAttribute("day"), 0);
    this.hour = dataElement.getAttribute("hour");
    this.dayName = dataElement.getAttribute("day_name");
    this.month = dataElement.getAttribute("month");
  }

  return SurfForecastData;
})();

var SurfForecast = (function() {
  SurfForecast.name = "SurfForecast";

  function SurfForecast(options) {
    // Create the kinetic stage we'll use to draw everything
    this.stage = new Kinetic.Stage({container: "surf_forecast", width: 709, height: 166});

    // Surf Data url is where we get the surf forecast data from
    this.surfDataUrl = options.surfDataUrl;

    // Beach Direction
    this.beachDirection = options.beachDir;

    // Set up initial properties for Sunrise
    this.sunSetHour = options.sset.substring(0, 1) + "pm";
    this.sunRiseHour = options.srise.substring(0, 1) + "am";
    this.backgroundLayer = new Kinetic.Layer();
    this.foregroundLayer = new Kinetic.Layer();
    this.graphWidth = 689;
    this.graphHeight = 119;
    this.graphOffsetX = 19.5;
    this.graphTop = 24.5;
    this.graphBottom = 141.5;

    this.stage.add(this.backgroundLayer);
    this.stage.add(this.foregroundLayer);
    this.fetchData();
  }

  SurfForecast.prototype._getPointNear = function(point) {
    return Math.round(point + 0.5) - 0.5;
  }

  SurfForecast.prototype.fetchData = function() {
    $.ajax(this.surfDataUrl, {
      success: $.proxy(this.bindData, this),
      cache: false
    });
  }

  SurfForecast.prototype.bindData = function(data, textStatus, xhr) {
    var dataPoints = data.getElementsByTagName("data");
    //console.log(data.documentElement.getAttribute("update"));
    this.surfDataUpdated = data.documentElement.getAttribute("update");
    var surfForecastDataArray = [];
    var firstDataPoint;
    for (var i = 0; i < dataPoints.length; i++) {
      var dataPoint = new SurfForecastData(dataPoints[i]);
      if (!firstDataPoint) {
        firstDataPoint = dataPoint;
      }
      if (dataPoint.day == firstDataPoint.day + 7 && dataPoint.hour == firstDataPoint.hour ) {
        break;
      } else {
        surfForecastDataArray.push(dataPoint);
      }
    }

    this.data = surfForecastDataArray;
    this.dataColumnWidth = this.graphWidth / this.data.length;

    this.generateSurfBackground();
    this.generateSurfForeground();
  }

  SurfForecast.prototype.generateSurfForeground = function() {
    for (var i = 0; i < this.data.length; i++) {
      var dataPoint = this.data[i];
    }
  }

  SurfForecast.prototype.generateBackground = function() {
    // Build the background rectangle
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: 709,
      height: 60,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    rect.setCornerRadius(3);
    this.backgroundLayer.add(rect);
    rect = new Kinetic.Rect({
      x: 0,
      y: 50,
      width: 709,
      height: 116,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    this.backgroundLayer.add(rect);

    // Build the surrounding rectangle
    rect = new Kinetic.Rect({
        x: this.graphOffsetX,
        y: 23.5,
        width: this.graphWidth,
        height: this.graphHeight,
        stroke: "#969696",
        fill: "#ffffff",
        strokeWidth: 1
    });
    this.backgroundLayer.add(rect);


    // Build the day seperators
    var points, sunSetIndex, days = 0;
    for (var i = 0; i < this.data.length; i++) {
      if (this.data[i].hour === "12am") {
        points = []
        var x = this._getPointNear((i * this.dataColumnWidth) + this.graphOffsetX);
        points.push(x);
        points.push(this.graphTop);
        points.push(x);
        points.push(this.graphBottom);
        var daySeperatorLine = new Kinetic.Line({
          points: points,
          stroke: '#d9d9d9',
          strokeWidth: 1
        });
        this.backgroundLayer.add(daySeperatorLine);

        // Create the Day labels
        if (days < 6) {
          points = [];
          points.push(x);
          points.push(1);
          points.push(x);
          points.push(21);
          var labelSeperatorLine = new Kinetic.Line({
            points: points,
            stroke: '#ffffff',
            strokeWidth: 1
          });
          this.backgroundLayer.add(labelSeperatorLine);

          var dayLabelText = new Kinetic.Text({
            x: x + 16,
            y: 6,
            text: this.data[i].dayName + " " + this.data[i].month + "-" + this.data[i].day,
            textFill: "#064a77",
            fontFamily: 'Verdana',
            fontSize: 10
          });
          this.backgroundLayer.add(dayLabelText);

          days++;
        }
      }


      // Build the dark rectangles
      if (this.data[i].hour == this.sunSetHour) {
        sunSetIndex = i;
      }

      if (this.data[i].hour == this.sunRiseHour) {
        rect = new Kinetic.Rect ({
          x: this._getPointNear((sunSetIndex * this.dataColumnWidth) + this.graphOffsetX),
          y: this.graphTop,
          width: Math.floor((i - sunSetIndex) * this.dataColumnWidth),
          height: this.graphBottom - this.graphTop,
          stroke: "#eeeeee",
          fill: "#eeeeee",
          strokeWidth: 1
        });
        this.backgroundLayer.add(rect);
        rect.setZIndex(rect.getZIndex() - 3);
      }
    }
  }

  SurfForecast.prototype.generateSurfBackground = function() {
    this.generateBackground();

    // Build the legend below the chart
    var rect = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.backgroundLayer.add(rect);

    var labelText = new Kinetic.Text({
      x: 4.5,
      y: this.graphBottom + 8,
      textFill: "#0E4A75",
      text: "Forecast Updated: " + this.surfDataUpdated,
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Clean Rect
    rect = new Kinetic.Rect({
      x: 226,
      y: 150,
      width: 24,
      height: 8,
      fill: "#6ddc5d"
    });
    this.backgroundLayer.add(rect);

    // Clean Label
    labelText = new Kinetic.Text({
      x: 255,
      y: 150,
      textFill: "#0E4A75",
      text: "Clean",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Fair Rect
    rect = new Kinetic.Rect({
      x: 312,
      y: 150,
      width: 24,
      height: 8,
      fill: "#5d68ff"
    });
    this.backgroundLayer.add(rect);
    
    // Fair Label
    labelText = new Kinetic.Text({
      x: 341,
      y: 150,
      textFill: "#0E4A75",
      text: "Fair",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Choppy Rect
    rect = new Kinetic.Rect({
      x: 387,
      y: 150,
      width: 24,
      height: 8,
      fill: "#fe6a63"
    });
    this.backgroundLayer.add(rect);
    
    // Choppy Label
    labelText = new Kinetic.Text({
      x: 416,
      y: 150,
      textFill: "#0E4A75",
      text: "Choppy",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Direction Label
    labelText = new Kinetic.Text({
      x: 479,
      y: 150,
      textFill: "#0E4A75",
      text: "Beach Direction: ",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Direction Button
    labelText = new Kinetic.Text({
      x: 577,
              y: 147,
              text: this.beachDirection,
              fill: '#646464',
              textFill: '#ffffff',
              width: 29,
              //lineHeight: 13,
              padding: 2,
              align: 'center',
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);



    // Build the Y Axis Labels and dashed lines
    var dashedDrawFunction = function(canvas) {
      // This function draws a horizontal dashed line so it cheats
      var points = this.attrs.points;
      var dashArray = this.attrs.dashArray;

      // Initial points are the first two entries. y won't change on a horizontal line
      var x = points[0].x;
      var y = points[0].y;

      var dashLength = dashArray[0];
      var gapLength = dashArray[1];

      // Cheating here. The length of the line is the difference in the x axis
      var length = points[1].x - points[0].x;
      var currentLength = 0;


      // Start drawing the line
      var context = canvas.getContext();
      context.beginPath();
      context.moveTo(x, y);

      while ((currentLength + dashLength + gapLength) < length) {
        context.lineTo(x + dashLength + currentLength, y);
        currentLength += dashLength;

        context.moveTo(x + gapLength + currentLength, y);
        currentLength += gapLength;
      }

      // end the line
      context.lineTo(x + dashLength + currentLength, y);

      //context.stroke();
      //context.closePath();
      //context.lineWidth = this.attrs.strokeWidth;
      canvas.fillStroke(this);
    }
    /*var dashedLine = new Kinetic.Line({
      drawFunc: dashedDrawFunction,
      stroke: 'black',
      strokeWidth: 1,
      points: [100.5, 100.5, 500.5, 100.5],
      dashArray: [10, 14]
    });
    this.backgroundLayer.add(dashedLine);*/

    var yMaxValue = 80;
    var yMinValue = 0;
    var datapointHeight = this.graphHeight / (yMaxValue - yMinValue);

    var labels = ["D-OH", "O-Head", "Head", "Shoulder", "Chest", "Waist", "Knee"];
    
    for (var i = 1; i < 8; i++) {
      var y = this._getPointNear(this.graphTop + (i * datapointHeight * 10));
      var dashedLine = new Kinetic.Line({
        drawFunc: dashedDrawFunction,
        stroke: '#d6d6d6',
        strokeWidth: 1,
        points: [45.5, y, 684.5, y],
        dashArray: [11, 14]
      });
      this.backgroundLayer.add(dashedLine);

      // Draw the Major Tick
      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [20.5, y, 29.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [698.5, y, 708.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      // Draw the Left Tick Labels
      var labelText = new Kinetic.Text({
        x: 33.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);

      // Draw the Right Tick Labels
      labelText = new Kinetic.Text({
        x: 640.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);
    }


    this.backgroundLayer.draw();
  }

  return SurfForecast;
})();


<% environment.context_class.instance_eval {include Rails.application.routes.url_helpers } %>
$(document).ready(function() {
  if ($("#surf_forecast").length > 0) {
    new SurfForecast({
      surfDataUrl: "<%= forecast_surf_data_path %>",
      sset: "4:42",
      srise: "7:14",
      beachDir: "E"
    });
  }
});
