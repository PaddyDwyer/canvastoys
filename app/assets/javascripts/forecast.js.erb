// This is used to set up the routes. it can be deleted
<% environment.context_class.instance_eval {include Rails.application.routes.url_helpers } %>

// This is data object that the surf forecast xml is bound too
var SurfForecastData= (function() {
  SurfForecastData.name = "SurfForecastData";

  function SurfForecastData(data) {
    var dataPoints = data.getElementsByTagName("data");
    this.surfDataUpdated = data.documentElement.getAttribute("update");
    this.dataPoints = [];
    for (var i = 0; i < dataPoints.length; i++) {
      var dataPoint = new SurfForecastDataPoint(dataPoints[i]);
      this.dataPoints.push(dataPoint);
    }
  }

  return SurfForecastData;
})();

// This is data object that the surf forecast xml is bound too
var SurfForecastDataPoint = (function() {
  SurfForecastDataPoint.name = "SurfForecastDataPoint";

  function SurfForecastDataPoint(dataElement) {
    this.day = ("0" + dataElement.getAttribute("day")).substr(-2);
    this.dayNum = parseInt(this.day, 10);
    this.hour = dataElement.getAttribute("hour");
    this.dayName = dataElement.getAttribute("day_name");
    this.month = dataElement.getAttribute("month");
    this.surf = parseInt(dataElement.getAttribute("surf"), 10);
    this.cond = dataElement.getAttribute("cond");
    this.swell1 = dataElement.getAttribute("swell1");
    this.swell2 = dataElement.getAttribute("swell2");
    this.wind = dataElement.getAttribute("wind");
  }

  return SurfForecastDataPoint;
})();

// This is data object that the swell forecast xml is bound too
var SwellForecastData = (function() {
  SwellForecastData.name = "SwellForecastData";

  function SwellForecastData(data) {
    var dataPoints = data.getElementsByTagName("data");
    this.dataPoints = [];
    for (var i = 0; i < dataPoints.length; i++) {
      var dataPoint = new SwellForecastDataPoint(dataPoints[i]);
      this.dataPoints.push(dataPoint);
    }
  }

  SwellForecastData.prototype.getMaxHeight = function() {
    var maxHeight = 0;
    for (var i = 0; i < this.dataPoints.length; i++) {
      var dataPoint = this.dataPoints[i];
      for (var j = 0; j < dataPoint.heights.length; j++) {
        if (dataPoint.heights[j] > maxHeight) {
          maxHeight = dataPoint.heights[j];
        }
      }
    }
    return maxHeight;
  }

  return SwellForecastData;
})();

// This is data object that the swell forecast xml is bound too
var SwellForecastDataPoint = (function() {
  SwellForecastDataPoint.name = "SwellForecastDataPoint";

  function SwellForecastDataPoint(dataElement) {
    this.day = ("0" + dataElement.getAttribute("day")).substr(-2);
    this.dayNum = parseInt(this.day, 10);
    this.hour = dataElement.getAttribute("hour");
    this.dayName = dataElement.getAttribute("day_name");
    this.month = dataElement.getAttribute("month");
    this.heights = [];
    this.periods = [];
    this.directions = [];
    for (var i = 0; i < 6; i++) {
      this.heights.push(parseFloat(dataElement.getAttribute("ht" + i)));
      this.periods.push(dataElement.getAttribute("per" + i));
      this.directions.push(dataElement.getAttribute("dir" + i));
    }
  }

  return SwellForecastDataPoint;
})();

var SurfForecast = (function() {
  SurfForecast.name = "SurfForecast";

  // Constructor. Takes an options object which sets up the Surf Forecast.
  function SurfForecast(options) {
    // Create the kinetic stage we'll use to draw everything
    var scale = {
      x:709 / 709,
      y:166 / 166
    };
    this.stage = new Kinetic.Stage({container: "surf_forecast", width: 709, height: 166, scale: scale});

    // The location Dirs are used to set up the beach directions. Also used for fetching
    // beach direction surf info.
    this.locationDirs = options.locationDir.split("||");
    var locationKey = options.locationKey;

    // The filenames are stored in an object which is keyed off location dir because we want to
    // be able to easily determine where to get data from. The beach direction buttons have a 
    // property on them with the location dir so it's easy to determine.
    this.filenames = {};
    this.filenames[this.locationDirs[0]] = locationKey;

    for (var i = 1; i < this.locationDirs.length; i++) {
      this.filenames[this.locationDirs[i]] = locationKey + "_" + this.locationDirs[i].toLowerCase();
    }

    // Beach Direction
    this.beachDirection = options.beachDir;

    // Set up initial properties for Sunrise & Sunset
    this.sunSetHour = options.sset.substring(0, 1) + "pm";
    this.sunRiseHour = options.srise.substring(0, 1) + "am";

    this.sunRiseFraction = options.srise.substring(2, 4) / 60;
    this.sunSetFraction = options.sset.substring(2, 4) / 60;

    // The base layer is where we keep stuff common to both charts
    this.baseLayer = new Kinetic.Layer();

    // The background layer is where we keep the y axis info and any legend details
    this.backgroundLayer = new Kinetic.Layer();

    // The foreground layer is where we keep the chart data itself
    this.foregroundLayer = new Kinetic.Layer();

    // The mouse over layer is where the mouse over elements are displayed
    this.mouseOverLayer = new Kinetic.Layer();
    // This is for the white background that goes over the legend
    var mouseOverTimeWhiteBackground = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.mouseOverLayer.add(mouseOverTimeWhiteBackground);
    // The mouse over layer is only displayed when the user mouses over the chart.
    this.mouseOverLayer.hide();

    // The mouse over control layer sits at the top and listens for mouse over events.
    // It can get hidden when the user first views the swell forecast
    this.mouseOverControlLayer = new Kinetic.Layer();
    // Set up graph dimensions
    this.graphWidth = 689;
    this.graphHeight = 119;
    this.graphLeft = 19.5;
    this.graphRight = this.graphLeft + this.graphWidth;
    this.graphTop = 24.5;
    this.graphBottom = 141.5;
    this.surfVerticalDataPoints = 80;

    // Add the layers to the kinetic stage
    this.stage.add(this.baseLayer);
    this.stage.add(this.backgroundLayer);
    this.stage.add(this.foregroundLayer);
    this.stage.add(this.mouseOverLayer);
    this.stage.add(this.mouseOverControlLayer);

    // Surf data is displayed first by default
    this.fetchSurfData();
  }

  // Private method used to get the point at the nearest 0.5. Canvas horizontal and vertical
  // lines don't look well defined at 1px unless they have a .5 in them.
  SurfForecast.prototype._getPointNear = function(point) {
    return Math.round(point + 0.5) - 0.5;
  }

  // Ajax call to get the surf forecast data
  // It can be provided with a beach direction to get the beach surf data
  SurfForecast.prototype.fetchSurfData = function(direction) {
    direction = direction || this.beachDirection;
    _this = this;
    // change the base path to the actual data timeline path
    var basePath = "/canvas/data/timelines/";
    $.ajax(basePath + this.filenames[direction] + ".xml", {
      success: function(data, textStatus, xhr) {
        _this.bindSurfData(data, textStatus, xhr, direction);
      },
      cache: false 
    });
  }

  // Ajax call to get the swell data
  SurfForecast.prototype.fetchSwellData = function() {
    _this = this;
    // change the base path to the actual data bull xmls path
    var basePath = "/canvas/data/bull_xml/";
    $.ajax(basePath + this.filenames[this.locationDirs[0]] + ".xml", {
      success: $.proxy(this.bindSwellData, this),
      cache: false
    });
  }

  // Binds data to the surf forecast and sets up various utility data points
  SurfForecast.prototype.bindSurfData = function(data, textStatus, xhr, direction) {
    this.selectedForecast = "surfButton";
    this.data = new SurfForecastData(data);

    //this.data = surfForecastDataArray;
    this.dataColumnWidth = this.graphWidth / (this.data.dataPoints.length - 1);
    this.surfDataHeight = this.graphHeight / this.surfVerticalDataPoints;

    // If we've already created the surf background we don't want to do it again.
    if (this.backgroundLayer.get("#beachDirectionLabel").length > 0) {
      this.updateSurfBackground(direction);
    } else {
      this.generateSurfBackground(direction);
    }
    this.generateSurfForeground();

    this.mouseOverControlLayer.show();
  }

  // Binds data for the swell forecast and draws the background and foreground
  SurfForecast.prototype.bindSwellData = function(data, textStatus, xhr) {
    this.selectedForecast = "swellButton";

    this.data = new SwellForecastData(data);

    this.dataColumnWidth = this.graphWidth / (this.data.dataPoints.length - 1);

    this.generateSwellBackground();
    this.generateSwellForeground();

    this.mouseOverControlLayer.hide();
  }

  // Draws the swell background y axis labels and legend below the graph
  SurfForecast.prototype.generateSwellBackground = function() {
    // Swell background is never called first so we just update the base layer
    this.updateBaseLayer();
    this.backgroundLayer.removeChildren();

    // Build the legend below the chart
    var labelText = new Kinetic.Text({
      x: 4.5,
      y: this.graphBottom + 8,
      textFill: "#383838",
      text: "Click swell color for roll over details",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Swell buttons follow a fairly standard pattern so we build all 6 programmatically
    var swellButtonColors = [ "#FF0000", "#0000FF", "#228B22", "#DB7093", "#00FFFF", "#FFA500" ];

    for (var i = 0; i < swellButtonColors.length; i++) {
      // Swell Button Rect
      var swellButtonGroup = new Kinetic.Group({
        id: "Swell" + (i + 1),
        name: "swellButtonGroup",
        x: 220 + (i * 81),
        y: 149,
      });
      var rect = new Kinetic.Rect({
        name: "Swell" + (i + 1),
        width: 24,
        height: 8,
        fill: swellButtonColors[i]
      });
      swellButtonGroup.add(rect);

      // Swell Button Label
      labelText = new Kinetic.Text({
        name: "Swell" + (i + 1),
        x: 30,
        y: 1,
        textFill: "#383838",
        text: "Swell " + (i + 1),
        fontFamily: 'Verdana',
        fontSize: 8
      });
      swellButtonGroup.add(labelText);

      swellButtonGroup.on("mouseover", $.proxy(this.swellButtonMouseOverHandler, this));
      swellButtonGroup.on("mouseout", $.proxy(this.swellButtonMouseOutHandler, this));
      swellButtonGroup.on("click tap", $.proxy(this.swellButtonClickHandler, this));
      this.backgroundLayer.add(swellButtonGroup);
    }
    

    // Build the Y Axis Labels and dashed lines
    // Get the Max Height
    // The algorithm for this is based off the flash algo
    // The adding of 1 to the max height is done in the while loop below
    var maxHeight = Math.ceil(this.data.getMaxHeight());
    var scale = false;
    // We put tick options into an array as the whole thing is done programmatically
    var tickOptions = [3, 4, 5];
    var ticks;
    // Get the correct scale
    while (scale == false) {
      maxHeight++;
      for (var i = 0; i < tickOptions.length; i++) {
        if (maxHeight % tickOptions[i] == 0) {
          ticks = tickOptions[i];
          scale = true;
        }
      }
    }
    // Once we have the scale draw the y axis labels
    if (scale) {
      var tickInt = maxHeight / ticks;
      this.swellDataHeight = this.graphHeight / maxHeight;
      var tickLabels = [];
      // Tick labels are all of a common format. We create an array containing the ticklabels
      // in reverse order as that is how they will be drawn.
      for (var i = ticks - 1; i > 0; i--) {
        tickLabels.push((i * tickInt) + " ft");
      }
      for (var i = 1; i < ticks; i++) {
        var y = this._getPointNear(this.graphTop + (i * tickInt * this.swellDataHeight));
        // Draw the dashed line. Use the custom functions again
        var dashedLine = new Kinetic.Line({
          drawFunc: dashedDrawFunction,
          stroke: '#d6d6d6',
          strokeWidth: 1,
          points: [68.5, y, 650.5, y],
          dashArray: [11, 13]
        });
        this.backgroundLayer.add(dashedLine);

        // Draw the left labels
        var labelText = new Kinetic.Text({
          x: 33.5,
          y: y - 4,
          textFill: "#0E4A75",
          text: tickLabels[i - 1],
          fontFamily: 'Verdana',
          fontSize: 8
        });
        this.backgroundLayer.add(labelText);

        // Draw the right labels
        labelText = new Kinetic.Text({
          x: 670.5,
          y: y - 4,
          textFill: "#0E4A75",
          text: tickLabels[i - 1],
          fontFamily: 'Verdana',
          fontSize: 8
        });
        this.backgroundLayer.add(labelText);

        // Draw the major ticks
        var majorTickLine = new Kinetic.Line({
          stroke: '#003366',
          strokeWidth: 1,
          points: [20.5, y, 29.5, y]
        });
        this.backgroundLayer.add(majorTickLine);

        var majorTickLine = new Kinetic.Line({
          stroke: '#003366',
          strokeWidth: 1,
          points: [698.5, y, 708.5, y]
        });
        this.backgroundLayer.add(majorTickLine);
      }
    }

    this.backgroundLayer.draw();
  }

  // Generate the graph for the swell forecast
  SurfForecast.prototype.generateSwellForeground = function() {
    this.foregroundLayer.removeChildren();

    // Do everything for the swell forecast in groups of 6
    var colors = ["#FE1D00", "#0016FF", "#2B8A13", "#DA7393", "#15FEFF", "#FFA600"];
    var points = [ [], [], [], [], [], [] ], x, y;
    var groups = [];
    for (var i = 1; i <= 6; i++) {
      // We'll store the lines in groups for easy showing and hiding
      var group = new Kinetic.Group({
        id: "Swell" + i + "Group",
        name: "swellLineGroup",
      });
      groups.push(group);
      this.foregroundLayer.add(group);
    }
    for (var i = 0; i < this.data.dataPoints.length; i++) {
      var dataPoint = this.data.dataPoints[i];
      for (var j = 0; j < dataPoint.heights.length; j++) {
        x = (i * this.dataColumnWidth) + this.graphLeft;
        y = this.graphBottom - (dataPoint.heights[j] * this.swellDataHeight);

        // Only add points to a line if they have a high enough height
        if (dataPoint.heights[j] > 0.7) {
          // Start a new line
          if (!points[j]) {
            points[j] = [{x: x, y: y}];
          } else { // continue line
            points[j].push({x: x, y: y});
          }
        }

        // Check to see if we need to end a line
        if (dataPoint.heights[j] < 0.7 || i == this.data.dataPoints.length - 1)  { 
          // Need 2 points to make a line
          if (points[j] && points[j].length > 1) {
            var line = new Kinetic.Line({
              points: points[j],
              stroke: colors[j],
              strokeWidth: 1
            });
            groups[j].add(line);
          }
          // Reset points whenever there is no valid value because there 
          // may be 1 point in the array
          points[j] = null;
        }
      }
    }


    this.foregroundLayer.draw();
  }

  SurfForecast.prototype.generateSurfForeground = function() {
    this.foregroundLayer.removeChildren();
    var _this = this;
    // Use RGBA for the fills so we can get an alpha fill
    var fillConditionColors = {"0": "rgba(204, 204, 204, 0.3)",
      "1": "rgba(0, 200, 0, 0.3)",
      "2": "rgba(0, 0, 256, 0.3)",
      "3": "rgba(256, 0, 0, 0.3)"};
    var strokeConditionColors = {"0": "#CCCCCC",
      "1": "#00C800",
      "2": "#0000FF",
      "3": "#FF0000"};

    // To draw the surf graph we draw it in two parts. The dark line is a line and the alpha fill 
    // is a polygon with no stroke. This was required because other wise you'd have a stroke all
    // the way around the fills.
    var lastCondition, lastPoint, fillPoints, fillColor, strokePoints, strokeColor, endLine;
    for (var i = 0; i < this.data.dataPoints.length;) {
      var dataPoint = this.data.dataPoints[i];

      // Start a new line
      if (lastPoint) {
        fillPoints = [((i - 1) * this.dataColumnWidth) + this.graphLeft, this.graphBottom];
        fillPoints = fillPoints.concat(lastPoint);
      } else {
        fillPoints = [(i * this.dataColumnWidth) + this.graphLeft, this.graphBottom];
      }
      fillColor = fillConditionColors[dataPoint.cond];
      strokePoints = lastPoint || [];
      strokeColor = strokeConditionColors[dataPoint.cond];

      // Add points of the same color to arrays
      lastCondition = dataPoint.cond
      while (dataPoint.cond == lastCondition && i < this.data.dataPoints.length) {
        dataPoint = this.data.dataPoints[i];
        x = (i * this.dataColumnWidth) + this.graphLeft;
        fillPoints.push(x);
        strokePoints.push(x);
        y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
        fillPoints.push(y);
        strokePoints.push(y);
        lastPoint = [x, y];

        i++;
      }

      // Extend the last data point out so the graph looks full
      if (i == this.data.dataPoints.length) {
        x = (i * this.dataColumnWidth) + this.graphLeft;
        fillPoints.push(x);
        strokePoints.push(x);
        y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
        fillPoints.push(y);
        strokePoints.push(y);

        // Add the bottom of the fill Poly
        fillPoints.push((i * this.dataColumnWidth) + this.graphLeft);
        fillPoints.push(this.graphBottom);
      } else {
        // If it's not the end of the graph we still need to add the bottom point of the 
        // fill poly
        fillPoints.push(((i - 1) * this.dataColumnWidth) + this.graphLeft);
        fillPoints.push(this.graphBottom);
      }

      // End the line
      var fillPoly = new Kinetic.Polygon({
        points: fillPoints,
          fill: fillColor
      });
      this.foregroundLayer.add(fillPoly);
      var strokeLine = new Kinetic.Line({
        points: strokePoints,
        stroke: strokeColor,
        strokeWidth: 1
      });
      this.foregroundLayer.add(strokeLine);
    }

    this.foregroundLayer.draw();
  }

  // the forecase mouse over handler handles drawing the mouseover stuff
  // for both swells and surfs
  SurfForecast.prototype.forecastMouseOverHandler = function(evt) {
    var mousePosition = this.stage.getMousePosition();
    var touchPosition = this.stage.getTouchPosition();

    var mouseX = mousePosition.x || touchPosition.x;

    var eventType = null;
    if (mousePosition.x) {
      eventType = "mouse";
    } else if (touchPosition.x) {
      eventType = "touch";
    }

    // get the data point nearest to the x point
    var index = Math.round((mouseX - this.graphLeft) / this.dataColumnWidth);

    var dataPoint = this.data.dataPoints[index];

    var x = (index * this.dataColumnWidth) + this.graphLeft;

    if (this.selectedForecast == "surfButton") {
      var y = this.graphBottom - (dataPoint.surf * this.surfDataHeight);
    } else if (this.selectedForecast == "swellButton") {
      var swellIndex = this.selectedSwell.substr(-1) - 1;
      var y = this.graphBottom - (dataPoint.heights[swellIndex] * this.swellDataHeight);
    }


    this.mouseOverLayer.show();
    // Draw the data Point circle
    // We only draw stuff once. Otherwise we update it
    var circle = this.mouseOverLayer.get("#circle")[0];
    if (!circle) {
      circle = new Kinetic.Circle({
        id: "circle",
        x: x,
        y: y,
        radius: 2.5,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 1
      });
      this.mouseOverLayer.add(circle);
    } else {
      circle.show();
      circle.setPosition(x, y);
    }

    // Draw the Horizontal Line
    var horizontalLine = this.mouseOverLayer.get("#hline")[0];
    if ((x - this.graphLeft) < (this.graphWidth / 2)) {
      var points = [{x: this.graphLeft, y: y}, {x: x, y: y}];
    } else {
      var points = [{x: x, y: y}, {x: this.graphRight, y: y}];
    }
    if (!horizontalLine) {
      horizontalLine = new Kinetic.Line({
        id: "hline",
        points: points,
        stroke: "#000000",
        strokeWidth: 1
      });
      this.mouseOverLayer.add(horizontalLine);
    } else {
      horizontalLine.setPoints(points);
    }

    // Draw the Vertical Line
    var verticalLine = this.mouseOverLayer.get("#vline")[0];
    var points = [{x: x, y: this.graphBottom}, {x: x, y: y}];
    if (!verticalLine) {
      verticalLine = new Kinetic.Line({
        id: "vline",
        points: points,
        stroke: "#000000",
        strokeWidth: 1
      });
      this.mouseOverLayer.add(verticalLine);
    } else {
      verticalLine.setPoints(points);
    }

    // Draw the time label
    var timeLabel = this.mouseOverLayer.get("#timeLabel")[0];
    if (!timeLabel) {
      timeLabel = new Kinetic.Text({
        id: "timeLabel",
        x: x,
        y: this.graphBottom + 8,
        text: dataPoint.hour,
        textFill: "#000",
        fontFamily: 'Times',
        fontSize: 9
      });
      this.mouseOverLayer.add(timeLabel);
    } else {
      timeLabel.setText(dataPoint.hour);
      timeLabel.setPosition(x, this.graphBottom + 8);
    }

    // Get the position for the infoBoxes
    var infoBoxDelta = 0;
    if (eventType == "touch") {
      infoBoxDelta = 50;
    }
    if ((x - this.graphLeft) < (this.graphWidth / 2)) {
      var infoX = x + (25 + infoBoxDelta);
    } else {
      var infoX = x - (173 + infoBoxDelta);
    }
    if ((y - this.graphTop) > (this.graphHeight / 2)) {
      var infoY = y - 47;
    } else {
      var infoY = y;
    }
    // Draw the Surf Info Box
    if (this.selectedForecast == "surfButton") {
      // hide the swell info box if it exists
      var swellInfoBox = this.mouseOverLayer.get("#swellInfoBox")[0];
      if (swellInfoBox) {
        swellInfoBox.hide();
      }

      // create the surf info box if it doesn't exist
      var surfInfoBox = this.mouseOverLayer.get("#surfInfoBox")[0];
      if (!surfInfoBox) {
        surfInfoBox = new Kinetic.Group({
          id: "surfInfoBox",
          x: infoX,
          y: infoY,
        });
        var rect = new Kinetic.Rect({
          width: 148,
          height: 47,
          fill: "#000"
        });
        rect.setCornerRadius(6);
        surfInfoBox.add(rect);

        var swellsLabel = new Kinetic.Text({
          x: 5,
          y: 5,
          text: "Swells:",
          textFill: "#FFFFCC",
          fontSize: 7,
          fontFamily: "Verdana"
        });
        surfInfoBox.add(swellsLabel);

        var swells1Data = new Kinetic.Text({
          id: "swell1Data",
          x: 44,
          y: 5,
          textFill: "#FFFFFF",
          fontSize: 7,
          fontFamily: "Verdana",
          text: dataPoint.swell1
        });
        surfInfoBox.add(swells1Data);
        var swells2Data = new Kinetic.Text({
          id: "swell2Data",
          x: 44,
          y: 20,
          textFill: "#FFFFFF",
          fontSize: 7,
          fontFamily: "Verdana",
          text: dataPoint.swell2
        });
        surfInfoBox.add(swells2Data);

        var windLabel = new Kinetic.Text({
          x: 5,
          y: 34,
          text: "Wind:",
          textFill: "#FFFFCC",
          fontSize: 7,
          fontFamily: "Verdana"
        });
        surfInfoBox.add(windLabel);

        var windData = new Kinetic.Text({
          id: "windData",
          x: 44,
          y: 34,
          textFill: "#FFFFFF",
          fontSize: 7,
          fontFamily: "Verdana",
          text: dataPoint.wind
        });
        surfInfoBox.add(windData);
        this.mouseOverLayer.add(surfInfoBox);
      } else {
        // update the surf info box if it exists already
        surfInfoBox.show();
        surfInfoBox.setPosition(infoX, infoY);
        var swell1Data = surfInfoBox.get("#swell1Data")[0];
        swell1Data.setText(dataPoint.swell1);
        var swell2Data = surfInfoBox.get("#swell2Data")[0];
        swell2Data.setText(dataPoint.swell2);
        var windData = surfInfoBox.get("#windData")[0];
        windData.setText(dataPoint.wind);
      }
    } else if (this.selectedForecast == "swellButton") {
      // Hide the surf info box if we're displaying the swell info box
      var surfInfoBox = this.mouseOverLayer.get("#surfInfoBox")[0];
      if (surfInfoBox) {
        surfInfoBox.hide();
      }

      var swellInfoBox = this.mouseOverLayer.get("#swellInfoBox")[0];
      // create the swell info box if it doesn't exist yet
      if (!swellInfoBox) {
        swellInfoBox = new Kinetic.Group({
          id: "swellInfoBox",
          x: infoX,
          y: infoY,
        });
        var rect = new Kinetic.Rect({
          width: 148,
          height: 47,
          fill: "#000"
        });
        rect.setCornerRadius(6);
        swellInfoBox.add(rect);

        var heightLabel = new Kinetic.Text({
          x: 5,
          y: 5,
          text: "Height:",
          textFill: "#FFFFCC",
          fontSize: 8,
          fontFamily: "Verdana"
        });
        swellInfoBox.add(heightLabel);

        var heightData = new Kinetic.Text({
          id: "heightData",
          x: 74,
          y: 5,
          textFill: "#FFFFFF",
          fontSize: 7,
          fontFamily: "Verdana",
          text: dataPoint.heights[swellIndex] + " ft"
        });
        swellInfoBox.add(heightData);

        var periodLabel = new Kinetic.Text({
          x: 5,
          y: 20,
          text: "Period:",
          textFill: "#FFFFCC",
          fontSize: 8,
          fontFamily: "Verdana"
        });
        swellInfoBox.add(periodLabel);

        var periodData = new Kinetic.Text({
          id: "periodData",
          x: 74,
          y: 20,
          textFill: "#FFFFFF",
          fontSize: 7,
          fontFamily: "Verdana",
          text: dataPoint.periods[swellIndex] + " sec"
        });
        swellInfoBox.add(periodData);

        var directionLabel = new Kinetic.Text({
          x: 5,
          y: 34,
          text: "Direction:",
          textFill: "#FFFFCC",
          fontSize: 8,
          fontFamily: "Verdana"
        });
        swellInfoBox.add(directionLabel);

        var directionData = new Kinetic.Text({
          id: "directionData",
          x: 74,
          y: 34,
          textFill: "#FFFFFF",
          fontSize: 7,
          fontFamily: "Verdana",
          text: dataPoint.directions[swellIndex] + " deg"
        });
        swellInfoBox.add(directionData);
        this.mouseOverLayer.add(swellInfoBox);
      } else {
        // Only show the swell info box if there is a height
        if (dataPoint.heights[swellIndex] > 0) {
          swellInfoBox.show();
          swellInfoBox.setPosition(infoX, infoY);
          var heightData = swellInfoBox.get("#heightData")[0];
          heightData.setText(dataPoint.heights[swellIndex] + " ft");
          var periodData = swellInfoBox.get("#periodData")[0];
          periodData.setText(dataPoint.periods[swellIndex] + " sec");
          var directionData = swellInfoBox.get("#directionData")[0];
          directionData.setText(dataPoint.directions[swellIndex] + " deg");
        } else {
          swellInfoBox.hide();
        }
      }
    }

    this.mouseOverLayer.draw();
  }

  // Hide the entire mouse over layer on mouse out over the graph
  SurfForecast.prototype.surfMouseOutHandler = function() {
    this.mouseOverLayer.hide();
  }

  // Generate the general background of the chart and stuff
  SurfForecast.prototype.generateBackground = function() {
    // Build the background rectangle
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: 709,
      height: 60,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    rect.setCornerRadius(7);
    this.baseLayer.add(rect);
    rect = new Kinetic.Rect({
      x: 0,
      y: 50,
      width: 709,
      height: 116,
      stroke: '#dfe3ed',
      fill: '#dfe3ed',
      strokeWidth: 1
    });
    this.baseLayer.add(rect);

    // Build the surrounding rectangle
    rect = new Kinetic.Rect({
        x: this.graphLeft,
        y: 23.5,
        width: this.graphWidth,
        height: this.graphHeight,
        stroke: "#969696",
        fill: "#ffffff",
        strokeWidth: 1
    });
    this.baseLayer.add(rect);

    // make the right side line a little brighter
    var line = new Kinetic.Line({
      points: [this.graphRight, this.graphTop, this.graphRight, this.graphBottom],
      stroke: '#d9d9d9',
      strokeWidth: 1
    });
    this.baseLayer.add(line);

    var mouseOverGroup = new Kinetic.Group({
      x: this.graphLeft,
      y: this.graphTop
    });
    // Create the mouse over box
    var rect = new Kinetic.Rect({
      x: 0,
      y: 0,
      width: this.graphWidth,
      height: this.graphHeight,
    });
    rect.on('mouseout touchend', $.proxy(this.surfMouseOutHandler, this));
    rect.on('mousemove touchmove', $.proxy(this.forecastMouseOverHandler, this));
    mouseOverGroup.add(rect);
    this.mouseOverControlLayer.add(mouseOverGroup);
    this.mouseOverControlLayer.draw();

    this.generateDaySeperators();

    // White Box for the legend
    var rect = new Kinetic.Rect({
        x: 1,
        y: 143,
        width: 707, 
        height: 22,
        fill: "#ffffff"
    });
    this.baseLayer.add(rect);



    // Build Surf Button Group
    var buttonGroup = new Kinetic.Group({
      id: "surfButton",
      name: "forecastButtonGroup",
      x: 2.5,
      y: 81.5,
      rotationDeg: -90
    });

    rect = new Kinetic.Rect({
      name: "surfButton",
      width: 57,
      height: 15,
      fill: "#064a77",
      stroke: "#FFFFFF",
      strokeWidth: 1
    });
    buttonGroup.add(rect);

    var text = new Kinetic.Text({
      name: "surfButton",
      y: 4,
      width: 60,
      text: "SURF",
      textFill: "#FFFFFF",
      fontSize: 8,
      fontStyle: 'bold',
      fontFamily: 'Verdana',
      align: 'center'
    });
    buttonGroup.add(text);
    buttonGroup.on("mouseover", $.proxy(this.forecastButtonMouseOverHandler, this));
    buttonGroup.on("mouseout", $.proxy(this.forecastButtonMouseOutHandler, this));
    buttonGroup.on("click tap", $.proxy(this.forecastButtonClickHandler, this));
    this.baseLayer.add(buttonGroup);

    // Build Swell Button Group
    buttonGroup = new Kinetic.Group({
      id: "swellButton",
      name: "forecastButtonGroup",
      x: 2.5,
      y: 141.5,
      rotationDeg: -90
    });

    rect = new Kinetic.Rect({
      name: "swellButton",
      width: 58,
      height: 15,
      stroke: "#064a77",
      fill: "#FFFFFF",
      strokeWidth: 1
    });
    buttonGroup.add(rect);

    var text = new Kinetic.Text({
      name: "swellButton",
      y: 4,
      width: 60,
      text: "SWELLS",
      textFill: "#064a77",
      fontSize: 8,
      fontStyle: 'bold',
      fontFamily: 'Verdana',
      align: 'center'
    });
    buttonGroup.add(text);
    buttonGroup.on("mouseover", $.proxy(this.forecastButtonMouseOverHandler, this));
    buttonGroup.on("mouseout", $.proxy(this.forecastButtonMouseOutHandler, this));
    buttonGroup.on("click tap", $.proxy(this.forecastButtonClickHandler, this));
    this.baseLayer.add(buttonGroup);
    this.baseLayer.draw();
  }

  SurfForecast.prototype.generateDaySeperators = function() {
    var daySeperatorGroup = this.baseLayer.get("#daySeperatorGroup")[0];

    if (!daySeperatorGroup) {
      var daySeperatorGroup = new Kinetic.Group({
        id: "daySeperatorGroup"
      });
      this.baseLayer.add(daySeperatorGroup);
    }
    daySeperatorGroup.removeChildren();

    // Build the day seperators
    var points, sunSetIndex, days = 0;
    for (var i = 0; i < this.data.dataPoints.length; i++) {
      if (this.data.dataPoints[i].hour === "12am" && i != this.data.dataPoints.length - 1) {
        points = []
        var x = this._getPointNear((i * this.dataColumnWidth) + this.graphLeft);
        points.push(x);
        points.push(this.graphTop);
        points.push(x);
        points.push(this.graphBottom);
        var daySeperatorLine = new Kinetic.Line({
          points: points,
          stroke: '#d9d9d9',
          strokeWidth: 1
        });
        daySeperatorGroup.add(daySeperatorLine);

        // Create the Day labels
        if (days < 6) {
          points = [];
          points.push(x);
          points.push(1);
          points.push(x);
          points.push(21);
          var labelSeperatorLine = new Kinetic.Line({
            points: points,
            stroke: '#ffffff',
            strokeWidth: 1
          });
          daySeperatorGroup.add(labelSeperatorLine);

          var dayLabelText = new Kinetic.Text({
            x: x,
            y: 8,
            text: this.data.dataPoints[i].dayName + " " + this.data.dataPoints[i].month + "-" + this.data.dataPoints[i].day,
            textFill: "#064a77",
            fontFamily: 'Verdana',
            fontStyle: 'bold',
            fontSize: 8,
            align: 'center',
            width: this.dataColumnWidth * 24,
          });
          daySeperatorGroup.add(dayLabelText);

          days++;
        }
      }


      // Build the dark rectangles
      if (this.data.dataPoints[i].hour == this.sunSetHour) {
        sunSetIndex = i;
      }

      if (this.data.dataPoints[i].hour == this.sunRiseHour && sunSetIndex) {
        rect = new Kinetic.Rect ({
          x: this._getPointNear(((sunSetIndex + this.sunSetFraction) * this.dataColumnWidth) + this.graphLeft),
          y: this.graphTop,
          width: Math.floor(((i + this.sunRiseFraction) - (sunSetIndex + this.sunSetFraction)) * this.dataColumnWidth),
          height: this.graphBottom - this.graphTop,
          stroke: "#eeeeee",
          fill: "#eeeeee",
          strokeWidth: 1
        });
        daySeperatorGroup.add(rect);
        rect.setZIndex(rect.getZIndex() - 3);
        sunSetIndex = false;
      }

      // we want to create a shorter dark rectangle at the end
      if (i == this.data.dataPoints.length - 1 && sunSetIndex) {
        rect = new Kinetic.Rect ({
          x: this._getPointNear(((sunSetIndex + this.sunSetFraction) * this.dataColumnWidth) + this.graphLeft),
          y: this.graphTop,
          width: Math.floor((i - (sunSetIndex + this.sunSetFraction)) * this.dataColumnWidth),
          height: this.graphBottom - this.graphTop,
          stroke: "#eeeeee",
          fill: "#eeeeee",
          strokeWidth: 1
        });
        daySeperatorGroup.add(rect);
        rect.setZIndex(rect.getZIndex() - 3);
      }
    }
  }


  // This method is responsible for setting up the y axis labels and dashed line
  // and any legend info that appears below the chart
  SurfForecast.prototype.generateSurfBackground = function(direction) {
    // It's possible for generate Surf background to get called multiple times
    // and the first time it's called it has to create a bunch of stuff. Otherwise
    // only a few things need to be updated.
    if (this.baseLayer.get(".forecastButtonGroup").length > 0) {
      this.updateBaseLayer();
    } else {
      this.generateBackground();
    }
    // Remove everything from the background layer before we get started
    this.backgroundLayer.removeChildren();

    // Build the legend below the chart
    var labelText = new Kinetic.Text({
      x: 4.5,
      y: this.graphBottom + 8,
      textFill: "#383838",
      text: "Forecast Updated: " + this.data.surfDataUpdated,
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Clean Rect
    var rect = new Kinetic.Rect({
      x: 226,
      y: 150,
      width: 24,
      height: 8,
      fill: "#6ddc5d"
    });
    this.backgroundLayer.add(rect);

    // Clean Label
    labelText = new Kinetic.Text({
      x: 255,
      y: 150,
      textFill: "#383838",
      text: "Clean",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Fair Rect
    rect = new Kinetic.Rect({
      x: 312,
      y: 150,
      width: 24,
      height: 8,
      fill: "#5d68ff"
    });
    this.backgroundLayer.add(rect);
    
    // Fair Label
    labelText = new Kinetic.Text({
      x: 341,
      y: 150,
      textFill: "#383838",
      text: "Fair",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Choppy Rect
    rect = new Kinetic.Rect({
      x: 387,
      y: 150,
      width: 24,
      height: 8,
      fill: "#fe6a63"
    });
    this.backgroundLayer.add(rect);
    
    // Choppy Label
    labelText = new Kinetic.Text({
      x: 416,
      y: 150,
      textFill: "#383838",
      text: "Choppy",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Direction Label
    labelText = new Kinetic.Text({
      id: "beachDirectionLabel",
      x: 479,
      y: 150,
      textFill: "#383838",
      text: "Beach Direction: ",
      fontFamily: 'Verdana',
      fontSize: 8
    });
    this.backgroundLayer.add(labelText);

    // Beach Directions
    for (var i = 0; i < this.locationDirs.length; i++) {
      var buttonGroup = new Kinetic.Group({
        id: this.locationDirs[i],
        name: "directionButtonGroup",
        x: 576.5 + (i * 39),
        y: 146.5,
        width: 29,
        height: 14
      });
      // Make sure the selected beach direction is a selected style
      if (this.locationDirs[i] == direction) {
        // Beach Direction Button
        rect = new Kinetic.Rect({
          name: this.locationDirs[i],
          fill: "#646464",
          stroke: "#FFFFFF",
          strokeWidth: 1,
          width: 29,
          height: 14
        });
        // Beach Direction Button Text
        labelText = new Kinetic.Text({
          name: this.locationDirs[i],
          y: 3,
          text: this.locationDirs[i],
          textFill: '#ffffff',
          width: 29,
          align: 'center',
          fontFamily: 'Verdana',
          fontSize: 7
        });
      } else {
        rect = new Kinetic.Rect({
          name: this.locationDirs[i],
          fill: "#FFFFFF",
          stroke: "#646464",
          strokeWidth: 1,
          width: 29,
          height: 14
        });
        labelText = new Kinetic.Text({
          name: this.locationDirs[i],
          y: 3,
          text: this.locationDirs[i],
          textFill: '#646464',
          width: 29,
          align: 'center',
          fontFamily: 'Verdana',
          fontSize: 7
        });
      }
      buttonGroup.add(rect);
      buttonGroup.add(labelText);
      buttonGroup.on("mouseover", $.proxy(this.directionButtonMouseOverHandler, this));
      buttonGroup.on("mouseout", $.proxy(this.directionButtonMouseOutHandler, this));
      buttonGroup.on("click tap", $.proxy(this.directionButtonClickHandler, this));
      this.backgroundLayer.add(buttonGroup);
    }



    // Build the Y Axis Labels and dashed lines
    var yMaxValue = this.surfVerticalDataPoints;
    var yMinValue = 0;
    var datapointHeight = this.graphHeight / (yMaxValue - yMinValue);

    var labels = ["D-OH", "O-Head", "Head", "Shoulder", "Chest", "Waist", "Knee"];
    
    for (var i = 1; i < 8; i++) {
      var y = this._getPointNear(this.graphTop + (i * datapointHeight * 10));
      // The dashes line uses a custom draw function to get the dashed appearance.
      var dashedLine = new Kinetic.Line({
        drawFunc: dashedDrawFunction,
        stroke: '#d6d6d6',
        strokeWidth: 1,
        points: [93.5, y, 634.5, y],
        dashArray: [11, 13]
      });
      this.backgroundLayer.add(dashedLine);

      // Draw the Major Tick
      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [20.5, y, 29.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      var majorTickLine = new Kinetic.Line({
        stroke: '#003366',
        strokeWidth: 1,
        points: [698.5, y, 708.5, y]
      });
      this.backgroundLayer.add(majorTickLine);

      // Draw the Left Tick Labels
      var labelText = new Kinetic.Text({
        x: 33.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);

      // Draw the Right Tick Labels
      labelText = new Kinetic.Text({
        x: 640.5,
        y: y - 4,
        textFill: "#0E4A75",
        text: labels[i - 1],
        fontFamily: 'Verdana',
        fontSize: 8
      });
      this.backgroundLayer.add(labelText);
    }


    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.updateSurfBackground = function(direction) {
    this.updateBaseLayer();


    // Update the surf direction buttons
    var buttonGroups = this.backgroundLayer.get(".directionButtonGroup");

    for (var i = 0; i < buttonGroups.length; i++) {
      if (buttonGroups[i].getId() == direction) {
        this.selectedDirectionButton(buttonGroups[i]);
      } else {
        this.unselectedDirectionButton(buttonGroups[i]);
      }
    }
  }

  SurfForecast.prototype.updateBaseLayer = function() {
    this.baseLayer.clear();
    // Redraw the timeline
    this.generateDaySeperators();

    var buttonGroups = this.baseLayer.get(".forecastButtonGroup");
    for (var i = 0; i < buttonGroups.length; i++) {
      if (buttonGroups[i].getId() == this.selectedForecast) {
        this.selectedForecastbutton(buttonGroups[i]);
      } else {
        this.unselectedForecastButton(buttonGroups[i]);
      }
    }

    this.baseLayer.draw();
  }

  SurfForecast.prototype.forecastButtonMouseOverHandler = function(evt) {
    var shape = evt.shape;
    var group = this.baseLayer.get("#" + shape.getName())[0];

    this.selectedForecastbutton(group);

    this.baseLayer.draw();

    if (this.selectedForecast != shape.getName()) {
      $("#surf_forecast").css('cursor', 'pointer');
    }
  }

  SurfForecast.prototype.forecastButtonMouseOutHandler = function(evt) {
    var shape = evt.shape;
    if (this.selectedForecast != shape.getName()) {
      var group = this.baseLayer.get("#" + shape.getName())[0];
      this.unselectedForecastButton(group);
      $("#surf_forecast").css('cursor', 'auto');
    }

    this.baseLayer.draw();

    $("#surf_forecast").css('cursor', 'auto');
  }

  SurfForecast.prototype.forecastButtonClickHandler = function(evt) {
    var shape = evt.shape;
    var name = shape.getName();

    //this.foregroundLayer.removeChildren();
    //this.foregroundLayer.draw();

    if (name == "swellButton") {
      this.fetchSwellData();
    } else if (name == 'surfButton') {
      this.fetchSurfData();
    }
  }

  SurfForecast.prototype.selectedForecastbutton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#FFFFFF");
        buttons[i].setFill("#064a77");
      } else {
        buttons[i].setTextFill("#FFFFFF");
      }
    }
  }

  SurfForecast.prototype.unselectedForecastButton = function(group) {
      var buttons = group.getChildren();
      for (var i = 0; i < buttons.length; i++) {
        if (buttons[i].shapeType == "Rect") {
          buttons[i].setStroke("#064a77");
          buttons[i].setFill("#FFFFFF");
        } else {
          buttons[i].setTextFill("#064a77");
        }
      }
  }

  SurfForecast.prototype.directionButtonMouseOverHandler = function(evt) {
    var shape = evt.shape;

    // get button text and background
    this.selectedDirectionButton(this.backgroundLayer.get("#" + shape.getName())[0]);

    if (this.beachDirection != shape.getName()) {
      $("#surf_forecast").css('cursor', 'pointer');
    }
  }

  SurfForecast.prototype.selectedDirectionButton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#FFFFFF");
        buttons[i].setFill("#646464");
      } else {
        buttons[i].setTextFill("#FFFFFF");
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.unselectedDirectionButton = function(group) {
    var buttons = group.getChildren();
    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i].shapeType == "Rect") {
        buttons[i].setStroke("#646464");
        buttons[i].setFill("#FFFFFF");
      } else {
        buttons[i].setTextFill("#646464");
      }
    }

    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.directionButtonMouseOutHandler = function(evt) {
    var shape = evt.shape;
    var direction = shape.getName();

    // get button text and background
    if (this.beachDirection != direction) {
      this.unselectedDirectionButton(this.backgroundLayer.get("#" + shape.getName())[0]);
    }
    $("#surf_forecast").css('cursor', 'auto');
  }

  SurfForecast.prototype.directionButtonClickHandler = function(evt) {
    var shape = evt.shape;
    var direction = shape.getName();

    this.beachDirection = direction;
    this.fetchSurfData(direction);
  }

  SurfForecast.prototype.swellButtonMouseOverHandler = function(evt) {
    $("#surf_forecast").css('cursor', 'pointer');
  }

  SurfForecast.prototype.swellButtonMouseOutHandler = function(evt) {
    $("#surf_forecast").css('cursor', 'auto');
  }

  SurfForecast.prototype.swellButtonClickHandler = function(evt) {
    var shape = evt.shape;
    var swell = shape.getName();

    if (swell == this.selectedSwell) {
      this.showAllSwells();
      this.selectedSwell = "";
      this.mouseOverControlLayer.hide();
    } else {
      this.showSwell(swell);
      this.selectedSwell = swell;
      this.mouseOverControlLayer.show();
    }
  }

  SurfForecast.prototype.showSwell = function(swellName) {
    var swellLineGroups = this.foregroundLayer.get(".swellLineGroup");
    for (var i = 0; i < swellLineGroups.length; i++) {
      if (swellLineGroups[i].getId() != swellName + "Group") {
        swellLineGroups[i].hide();
      } else {
        swellLineGroups[i].show();
      }
    }
    this.foregroundLayer.draw();

    var swellButtonGroups = this.backgroundLayer.get(".swellButtonGroup");
    for (var i = 0; i < swellButtonGroups.length; i++) {
      if (swellButtonGroups[i].getId() != swellName) {
        swellButtonGroups[i].setOpacity(0.35);
      } else {
        swellButtonGroups[i].setOpacity(1);
      }
    }
    this.backgroundLayer.draw();
  }

  SurfForecast.prototype.showAllSwells = function() {
    var swellLineGroups = this.foregroundLayer.get(".swellLineGroup");
    for (var i = 0; i < swellLineGroups.length; i++) {
      swellLineGroups[i].show();
    }
    this.foregroundLayer.draw();

    var swellButtonGroups = this.backgroundLayer.get(".swellButtonGroup");
    for (var i = 0; i < swellButtonGroups.length; i++) {
      swellButtonGroups[i].setOpacity(1);
    }
    this.backgroundLayer.draw();
  }

  var dashedDrawFunction = function(canvas) {
    // This function draws a horizontal dashed line so it cheats
    var points = this.attrs.points;
    var dashArray = this.attrs.dashArray;

    // Initial points are the first two entries. y won't change on a horizontal line
    var x = points[0].x;
    var y = points[0].y;

    var dashLength = dashArray[0];
    var gapLength = dashArray[1];

    // Cheating here. The length of the line is the difference in the x axis
    var length = points[1].x - points[0].x;
    var currentLength = 0;


    // Start drawing the line
    var context = canvas.getContext();
    context.beginPath();
    context.moveTo(x, y);

    while ((currentLength + dashLength + gapLength) < length) {
      context.lineTo(x + dashLength + currentLength, y);
      currentLength += dashLength;

      context.moveTo(x + gapLength + currentLength, y);
      currentLength += gapLength;
    }

    // end the line
    context.lineTo(x + dashLength + currentLength, y);

    canvas.fillStroke(this);
  }


  return SurfForecast;
})();


$(document).ready(function() {
  var canvas2DSupported = !!window.CanvasRenderingContext2D;
  if ($("#surf_forecast").length > 0 && canvas2DSupported) {
    new SurfForecast({
      locationDir: "SSE||SE",
      beachDir: "SE",
      locationKey: "wna_nj_oceancity",
      srise: "7:17",
      sset: "4:42",
    });
  }
});
